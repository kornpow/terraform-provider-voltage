// Package voltage provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package voltage

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
)

const (
	API_TokenScopes = "API_Token.Scopes"
)

// N400 defines model for 400.
type N400 struct {
	Message *string `json:"message,omitempty"`
}

// NodeDocument defines model for Node Document.
type NodeDocument struct {
	// ApiEndpoint API Endpoint for the node.
	ApiEndpoint    *string `json:"api_endpoint,omitempty"`
	CommandHistory *[]struct {
		// Action Action that was performed
		Action *string `json:"action,omitempty"`

		// Time Timestamp the event happened
		Time *string `json:"time,omitempty"`
	} `json:"command_history,omitempty"`

	// Created Date that the node was created.
	Created *string `json:"created,omitempty"`

	// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
	Expires *string `json:"expires,omitempty"`

	// LndVersion Version of LND the node is running
	LndVersion *string `json:"lnd_version,omitempty"`
	Macaroons  *[]struct {
		// Created Timestamp the macaroon was backed up at
		Created *string `json:"created,omitempty"`

		// Name Name of the backed up macaroon
		Name *string `json:"name,omitempty"`
	} `json:"macaroons,omitempty"`

	// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
	Network *string `json:"network,omitempty"`

	// NodeId Unique ID for the node.
	NodeId *string `json:"node_id,omitempty"`

	// NodeName User defined node name given at creation
	NodeName *string `json:"node_name,omitempty"`

	// PurchaseStatus Purchase status of the node.
	PurchaseStatus *string `json:"purchase_status,omitempty"`

	// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
	PurchasedType *string `json:"purchased_type,omitempty"`

	// Settings Settings for the Lightning Node
	Settings *NodeSettings `json:"settings,omitempty"`

	// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
	Status *string `json:"status,omitempty"`

	// Type Type of node, either 'standard' or 'lite'
	Type *string `json:"type,omitempty"`

	// UpdateAvailable Indicates if there is an update available
	UpdateAvailable *bool `json:"update_available,omitempty"`

	// VoltVersion Version of Voltage the node is running
	VoltVersion *string `json:"volt_version,omitempty"`
}

// NodeRequest defines model for Node Request.
type NodeRequest struct {
	// NodeId Voltage Node ID you're requesting
	NodeId string `json:"node_id"`
}

// NodeSettings Settings for the Lightning Node
type NodeSettings struct {
	// Alias Your node's Alias on the peer to peer network
	Alias *string `json:"alias,omitempty"`

	// Allowcircularroute If enabled, allows a payment to exit and enter the same channel
	Allowcircularroute *bool `json:"allowcircularroute,omitempty"`

	// Amp Enables AMP
	Amp *bool `json:"amp,omitempty"`

	// Autocompaction When enabled, LND will automatically compact the databases on startup
	Autocompaction *bool `json:"autocompaction,omitempty"`

	// Autopilot When enabled, LND will turn on its autopilot feature
	Autopilot *bool `json:"autopilot,omitempty"`

	// Basefee Your base fee rate for your channels
	Basefee *string `json:"basefee,omitempty"`

	// Color Your node's Color on the peer to peer network
	Color *string `json:"color,omitempty"`

	// Defaultfeerate Your default fee rate for your channels
	Defaultfeerate *string `json:"defaultfeerate,omitempty"`

	// Gccanceledinvoicesonstartup If enabled, deletes cancelled invoices only when LND starts up
	Gccanceledinvoicesonstartup *bool `json:"gccanceledinvoicesonstartup,omitempty"`

	// Gccanceledinvoicesonthefly If enabled, deletes cancelled invoices while LND is running
	Gccanceledinvoicesonthefly *bool `json:"gccanceledinvoicesonthefly,omitempty"`

	// Grpc When enabled, LND will active the gRPC API
	Grpc *bool `json:"grpc,omitempty"`

	// Keysend When enabled, LND will enable the Keysend feature
	Keysend *bool `json:"keysend,omitempty"`

	// Maxchansize The maximum channel size your node will accept
	Maxchansize *string `json:"maxchansize,omitempty"`

	// Maxpendingchannels Maximum number of pending channels allowed for a single peer
	Maxpendingchannels *string `json:"maxpendingchannels,omitempty"`

	// Minchansize The minimum channel size your node will accept
	Minchansize *string `json:"minchansize,omitempty"`

	// Numgraphsyncpeers Number of peers used for syncing the graph
	Numgraphsyncpeers *string `json:"numgraphsyncpeers,omitempty"`

	// Optionscidalias If enabled, and zeroconf is also enabled, it is possible to create zeroconf channels. See lnd docs.
	Optionscidalias *bool `json:"optionscidalias,omitempty"`

	// Rest When enabled, LND will active the REST API
	Rest *bool `json:"rest,omitempty"`

	// Rpcmiddleware Enables the rpcmiddleware, which can interecept certain rpc calls. See LND Docs.
	Rpcmiddleware *bool `json:"rpcmiddleware,omitempty"`

	// Torskipproxyforclearnettargets Optimization for clearnet peers. See LND Docs.
	Torskipproxyforclearnettargets *bool `json:"torskipproxyforclearnettargets,omitempty"`

	// Webhook Your webhook endpoint if you wish to receive webhook events
	Webhook *string `json:"webhook,omitempty"`

	// WebhookSecret Webhook secret used to validate the webhook is coming from us
	WebhookSecret *string `json:"webhook_secret,omitempty"`

	// Whitelist A list of IPs that are allowed to talk to your node
	Whitelist *[]string `json:"whitelist,omitempty"`

	// Wtclient Enables the watchtower client
	Wtclient *bool `json:"wtclient,omitempty"`

	// Wumbo When enabled, LND will accept Wumbo channels
	Wumbo *bool `json:"wumbo,omitempty"`

	// Zeroconf If enabled, and optionscidalias is also enabled, it is possible to create zeroconf channels. See lnd docs.
	Zeroconf *bool `json:"zeroconf,omitempty"`
}

// UserDocument defines model for User Document.
type UserDocument struct {
	// AvailableBtcpayservers Number of BTCPay Servers the user can create
	AvailableBtcpayservers *float32 `json:"available_btcpayservers,omitempty"`

	// AvailableLiteNodes Number of available Lite nodes the user can provision
	AvailableLiteNodes *float32 `json:"available_lite_nodes,omitempty"`

	// AvailableStandardNodes Number of available Standard nodes the user can provision
	AvailableStandardNodes *float32 `json:"available_standard_nodes,omitempty"`

	// BtcpayserverTrial Indicator if the user has a trial available for a BTCPay Server
	BtcpayserverTrial *bool `json:"btcpayserver_trial,omitempty"`

	// Email Email address for the user
	Email *string `json:"email,omitempty"`

	// EmailVerified Indicator if the user has verified their email
	EmailVerified *bool `json:"email_verified,omitempty"`

	// MfaEnabled Indicator if the user has MFA enabled
	MfaEnabled *bool `json:"mfa_enabled,omitempty"`

	// PurchasedLiteNodes Number of Lite nodes that user has purchased
	PurchasedLiteNodes *float32 `json:"purchased_lite_nodes,omitempty"`

	// PurchasedStandardNodes Number of Standard nodes that user has purchased
	PurchasedStandardNodes *float32 `json:"purchased_standard_nodes,omitempty"`

	// TrialAvailable Indicator if the user has a trial available for a node
	TrialAvailable *bool `json:"trial_available,omitempty"`

	// UserId Unique Voltage user ID
	UserId *string `json:"user_id,omitempty"`
}

// PostBtcpayserverJSONBody defines parameters for PostBtcpayserver.
type PostBtcpayserverJSONBody struct {
	// BtcpayserverId Unique ID for the BTCPay Store
	BtcpayserverId string `json:"btcpayserver_id"`
}

// PostBtcpayserverCreateJSONBody defines parameters for PostBtcpayserverCreate.
type PostBtcpayserverCreateJSONBody struct {
	// AccountKeyPath Account Key Path used for the onchain funds if created outside the store
	AccountKeyPath *string `json:"account_key_path,omitempty"`

	// BitcoinSeedBackup Encrypted backup of the onchain funds seed. DO NO SEND UNENCRYPTED DATA.
	BitcoinSeedBackup *string `json:"bitcoin_seed_backup,omitempty"`

	// DerivationScheme Derivation Scheme used for the onchain funds if created outside the store
	DerivationScheme *string `json:"derivation_scheme,omitempty"`

	// NodeId Unique ID of the node connected to this store
	NodeId *string `json:"node_id,omitempty"`

	// NodeMacaroon Hex value of a macaroon for BTCPay Server specifically
	NodeMacaroon *string `json:"node_macaroon,omitempty"`

	// StoreName A user generated name for the store
	StoreName string `json:"store_name"`
}

// PostBtcpayserverDeleteJSONBody defines parameters for PostBtcpayserverDelete.
type PostBtcpayserverDeleteJSONBody struct {
	// BtcpayserverId Unique ID of the BTCPay Store
	BtcpayserverId string `json:"btcpayserver_id"`
}

// PostBtcpayserverNodeUpdateJSONBody defines parameters for PostBtcpayserverNodeUpdate.
type PostBtcpayserverNodeUpdateJSONBody struct {
	// BtcpayserverId Unique ID for the BTCPay Store
	BtcpayserverId string `json:"btcpayserver_id"`

	// NodeId Unique ID of the node connected to this BTCPay Store
	NodeId string `json:"node_id"`

	// NodeMacaroon Hex value of a macaroon for BTCPay Server specifically
	NodeMacaroon string `json:"node_macaroon"`
}

// PostBtcpayserverSeedJSONBody defines parameters for PostBtcpayserverSeed.
type PostBtcpayserverSeedJSONBody struct {
	// BtcpayserverId Unique ID for the BTCPay Store
	BtcpayserverId string `json:"btcpayserver_id"`
}

// PostDashboardsJSONBody defines parameters for PostDashboards.
type PostDashboardsJSONBody struct {
	// DashboardId Unique ID of the dashboard
	DashboardId string `json:"dashboard_id"`
}

// PostDashboardsCreateJSONBody defines parameters for PostDashboardsCreate.
type PostDashboardsCreateJSONBody struct {
	// NodeId Unique ID for the node to create a dashboard for
	NodeId string `json:"node_id"`

	// Type Type of dashboard. Possible choices are 'thunderhub' or 'lnbits'
	Type string `json:"type"`
}

// PostDashboardsDeleteJSONBody defines parameters for PostDashboardsDelete.
type PostDashboardsDeleteJSONBody struct {
	// DashboardId Unique ID of the dashboard
	DashboardId string `json:"dashboard_id"`
}

// PostDashboardsStartJSONBody defines parameters for PostDashboardsStart.
type PostDashboardsStartJSONBody struct {
	// DashboardId Unique ID of the dashboard
	DashboardId string `json:"dashboard_id"`
}

// PostDashboardsStopJSONBody defines parameters for PostDashboardsStop.
type PostDashboardsStopJSONBody struct {
	// DashboardId Unique ID of the dashboard
	DashboardId string `json:"dashboard_id"`
}

// PostDashboardsUpdateeJSONBody defines parameters for PostDashboardsUpdatee.
type PostDashboardsUpdateeJSONBody struct {
	// DashboardId Unique ID of the dashboard
	DashboardId string `json:"dashboard_id"`
}

// PostExportJSONBody defines parameters for PostExport.
type PostExportJSONBody struct {
	// NodeId Unique ID for the node you want to create an export for
	NodeId string `json:"node_id"`

	// Type Type of export. Possible types are 'full', 'log', 'channelbackup', 'tls'
	Type string `json:"type"`
}

// PostFlowCancelJSONBody defines parameters for PostFlowCancel.
type PostFlowCancelJSONBody struct {
	// OrderId Flow Order ID
	OrderId string `json:"order_id"`
}

// PostFlowCreateJSONBody defines parameters for PostFlowCreate.
type PostFlowCreateJSONBody struct {
	// Bps Overwrite the default fee BPS and set your own.
	Bps *float32 `json:"bps,omitempty"`

	// Capacity Amount of requested satoshis of inbound liquidity.
	Capacity float32 `json:"capacity"`

	// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
	LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

	// NodeTier The Pool node tier you would like to purchase the channel from. Can be 'any' or 'best'.
	NodeTier *string `json:"node_tier,omitempty"`

	// SelfChanBalance Amount of requested satoshis of outbound liquidity.
	SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`
}

// PostFlowQuoteJSONBody defines parameters for PostFlowQuote.
type PostFlowQuoteJSONBody struct {
	// Bps Overwrite the default fee BPS and set your own.
	Bps *float32 `json:"bps,omitempty"`

	// Capacity Amount of requested satoshis of inbound liquidity.
	Capacity float32 `json:"capacity"`

	// LeaseDurationBlocks How many blocks you are purchasing the channel for. Supported durations are 2016, 4032, 12096, and 52416.
	LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

	// NodeTier The Pool node tier you would like to purchase the channel from. Can be 'any' or 'best'.
	NodeTier *string `json:"node_tier,omitempty"`

	// SelfChanBalance Amount of requested satoshis of outbound liquidity.
	SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`
}

// PostFlowRatingsJSONBody defines parameters for PostFlowRatings.
type PostFlowRatingsJSONBody struct {
	// Pubkey Node's Public Key
	Pubkey string `json:"pubkey"`
}

// PostFlowRedeemJSONBody defines parameters for PostFlowRedeem.
type PostFlowRedeemJSONBody struct {
	// Coupon Flow coupon code
	Coupon string `json:"coupon"`
}

// PostFlowStatusJSONBody defines parameters for PostFlowStatus.
type PostFlowStatusJSONBody struct {
	// OrderId Flow Order ID
	OrderId string `json:"order_id"`
}

// PostNodeConnectJSONBody defines parameters for PostNodeConnect.
type PostNodeConnectJSONBody struct {
	// Name name of the macaroon you to use when connecting
	Name string `json:"name"`

	// NodeId Unique ID of the node
	NodeId string `json:"node_id"`
}

// PostNodeCreateJSONBody defines parameters for PostNodeCreate.
type PostNodeCreateJSONBody struct {
	// Name User defined node name given at creation
	Name string `json:"name"`

	// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
	Network string `json:"network"`

	// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
	PurchasedType string `json:"purchased_type"`

	// Settings Settings for the Lightning Node
	Settings NodeSettings `json:"settings"`

	// Type Type of node, either 'standard' or 'lite'
	Type string `json:"type"`
}

// PostNodeMacaroonJSONBody defines parameters for PostNodeMacaroon.
type PostNodeMacaroonJSONBody struct {
	// Macaroon Encrypted string of the macaroon. DO NOT UPLOAD UNENCRYPTED DATA.
	Macaroon string `json:"macaroon"`

	// Name Name of the macaroon you are backing up
	Name string `json:"name"`

	// NodeId Unique ID of the node
	NodeId string `json:"node_id"`
}

// PostNodeNameJSONBody defines parameters for PostNodeName.
type PostNodeNameJSONBody struct {
	// Network Bitcoin network to use. Can be either 'mainnet' or 'testnet'.
	Network string `json:"network"`

	// NodeName Name to check
	NodeName string `json:"node_name"`
}

// PostNodeSettingsJSONBody defines parameters for PostNodeSettings.
type PostNodeSettingsJSONBody struct {
	// NodeId Unique ID of the node
	NodeId string `json:"node_id"`

	// Settings Settings for the Lightning Node
	Settings NodeSettings `json:"settings"`
}

// PostNodeUploadSeedJSONBody defines parameters for PostNodeUploadSeed.
type PostNodeUploadSeedJSONBody struct {
	// NodeId Unique ID of the node
	NodeId string `json:"node_id"`

	// Seed Encrypted string of the seed. DO NOT UPLOAD UNENCRYPTED DATA.
	Seed string `json:"seed"`
}

// PostNodeWhitelistJSONBody defines parameters for PostNodeWhitelist.
type PostNodeWhitelistJSONBody struct {
	// NodeId Unique ID of the node
	NodeId string `json:"node_id"`

	// Whitelist List of IP Addresses that are allowed to talk to your node
	Whitelist []interface{} `json:"whitelist"`
}

// PostBtcpayserverJSONRequestBody defines body for PostBtcpayserver for application/json ContentType.
type PostBtcpayserverJSONRequestBody PostBtcpayserverJSONBody

// PostBtcpayserverCreateJSONRequestBody defines body for PostBtcpayserverCreate for application/json ContentType.
type PostBtcpayserverCreateJSONRequestBody PostBtcpayserverCreateJSONBody

// PostBtcpayserverDeleteJSONRequestBody defines body for PostBtcpayserverDelete for application/json ContentType.
type PostBtcpayserverDeleteJSONRequestBody PostBtcpayserverDeleteJSONBody

// PostBtcpayserverNodeUpdateJSONRequestBody defines body for PostBtcpayserverNodeUpdate for application/json ContentType.
type PostBtcpayserverNodeUpdateJSONRequestBody PostBtcpayserverNodeUpdateJSONBody

// PostBtcpayserverSeedJSONRequestBody defines body for PostBtcpayserverSeed for application/json ContentType.
type PostBtcpayserverSeedJSONRequestBody PostBtcpayserverSeedJSONBody

// PostDashboardsJSONRequestBody defines body for PostDashboards for application/json ContentType.
type PostDashboardsJSONRequestBody PostDashboardsJSONBody

// PostDashboardsCreateJSONRequestBody defines body for PostDashboardsCreate for application/json ContentType.
type PostDashboardsCreateJSONRequestBody PostDashboardsCreateJSONBody

// PostDashboardsDeleteJSONRequestBody defines body for PostDashboardsDelete for application/json ContentType.
type PostDashboardsDeleteJSONRequestBody PostDashboardsDeleteJSONBody

// PostDashboardsStartJSONRequestBody defines body for PostDashboardsStart for application/json ContentType.
type PostDashboardsStartJSONRequestBody PostDashboardsStartJSONBody

// PostDashboardsStopJSONRequestBody defines body for PostDashboardsStop for application/json ContentType.
type PostDashboardsStopJSONRequestBody PostDashboardsStopJSONBody

// PostDashboardsUpdateeJSONRequestBody defines body for PostDashboardsUpdatee for application/json ContentType.
type PostDashboardsUpdateeJSONRequestBody PostDashboardsUpdateeJSONBody

// PostExportJSONRequestBody defines body for PostExport for application/json ContentType.
type PostExportJSONRequestBody PostExportJSONBody

// PostFlowCancelJSONRequestBody defines body for PostFlowCancel for application/json ContentType.
type PostFlowCancelJSONRequestBody PostFlowCancelJSONBody

// PostFlowCreateJSONRequestBody defines body for PostFlowCreate for application/json ContentType.
type PostFlowCreateJSONRequestBody PostFlowCreateJSONBody

// PostFlowQuoteJSONRequestBody defines body for PostFlowQuote for application/json ContentType.
type PostFlowQuoteJSONRequestBody PostFlowQuoteJSONBody

// PostFlowRatingsJSONRequestBody defines body for PostFlowRatings for application/json ContentType.
type PostFlowRatingsJSONRequestBody PostFlowRatingsJSONBody

// PostFlowRedeemJSONRequestBody defines body for PostFlowRedeem for application/json ContentType.
type PostFlowRedeemJSONRequestBody PostFlowRedeemJSONBody

// PostFlowStatusJSONRequestBody defines body for PostFlowStatus for application/json ContentType.
type PostFlowStatusJSONRequestBody PostFlowStatusJSONBody

// PostNodeJSONRequestBody defines body for PostNode for application/json ContentType.
type PostNodeJSONRequestBody = NodeRequest

// PostNodeCertJSONRequestBody defines body for PostNodeCert for application/json ContentType.
type PostNodeCertJSONRequestBody = NodeRequest

// PostNodeConnectJSONRequestBody defines body for PostNodeConnect for application/json ContentType.
type PostNodeConnectJSONRequestBody PostNodeConnectJSONBody

// PostNodeCreateJSONRequestBody defines body for PostNodeCreate for application/json ContentType.
type PostNodeCreateJSONRequestBody PostNodeCreateJSONBody

// PostNodeDashboardsJSONRequestBody defines body for PostNodeDashboards for application/json ContentType.
type PostNodeDashboardsJSONRequestBody = NodeRequest

// PostNodeDeleteJSONRequestBody defines body for PostNodeDelete for application/json ContentType.
type PostNodeDeleteJSONRequestBody = NodeRequest

// PostNodeLogsJSONRequestBody defines body for PostNodeLogs for application/json ContentType.
type PostNodeLogsJSONRequestBody = NodeRequest

// PostNodeMacaroonJSONRequestBody defines body for PostNodeMacaroon for application/json ContentType.
type PostNodeMacaroonJSONRequestBody PostNodeMacaroonJSONBody

// PostNodeNameJSONRequestBody defines body for PostNodeName for application/json ContentType.
type PostNodeNameJSONRequestBody PostNodeNameJSONBody

// PostNodeSeedJSONRequestBody defines body for PostNodeSeed for application/json ContentType.
type PostNodeSeedJSONRequestBody = NodeRequest

// PostNodeSettingsJSONRequestBody defines body for PostNodeSettings for application/json ContentType.
type PostNodeSettingsJSONRequestBody PostNodeSettingsJSONBody

// PostNodeStartJSONRequestBody defines body for PostNodeStart for application/json ContentType.
type PostNodeStartJSONRequestBody = NodeRequest

// PostNodeStopJSONRequestBody defines body for PostNodeStop for application/json ContentType.
type PostNodeStopJSONRequestBody = NodeRequest

// PostNodeUpdateJSONRequestBody defines body for PostNodeUpdate for application/json ContentType.
type PostNodeUpdateJSONRequestBody = NodeRequest

// PostNodeUploadSeedJSONRequestBody defines body for PostNodeUploadSeed for application/json ContentType.
type PostNodeUploadSeedJSONRequestBody PostNodeUploadSeedJSONBody

// PostNodeWhitelistJSONRequestBody defines body for PostNodeWhitelist for application/json ContentType.
type PostNodeWhitelistJSONRequestBody PostNodeWhitelistJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBtcpayserver request
	GetBtcpayserver(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBtcpayserver request with any body
	PostBtcpayserverWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBtcpayserver(ctx context.Context, body PostBtcpayserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBtcpayserverCreate request with any body
	PostBtcpayserverCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBtcpayserverCreate(ctx context.Context, body PostBtcpayserverCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBtcpayserverDelete request with any body
	PostBtcpayserverDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBtcpayserverDelete(ctx context.Context, body PostBtcpayserverDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBtcpayserverNodeUpdate request with any body
	PostBtcpayserverNodeUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBtcpayserverNodeUpdate(ctx context.Context, body PostBtcpayserverNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostBtcpayserverSeed request with any body
	PostBtcpayserverSeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostBtcpayserverSeed(ctx context.Context, body PostBtcpayserverSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDashboards request
	GetDashboards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDashboards request with any body
	PostDashboardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDashboards(ctx context.Context, body PostDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDashboardsCreate request with any body
	PostDashboardsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDashboardsCreate(ctx context.Context, body PostDashboardsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDashboardsDelete request with any body
	PostDashboardsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDashboardsDelete(ctx context.Context, body PostDashboardsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDashboardsStart request with any body
	PostDashboardsStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDashboardsStart(ctx context.Context, body PostDashboardsStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDashboardsStop request with any body
	PostDashboardsStopWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDashboardsStop(ctx context.Context, body PostDashboardsStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostDashboardsUpdatee request with any body
	PostDashboardsUpdateeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostDashboardsUpdatee(ctx context.Context, body PostDashboardsUpdateeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExport request
	GetExport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostExport request with any body
	PostExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostExport(ctx context.Context, body PostExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowBalance request
	GetFlowBalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFlowCancel request with any body
	PostFlowCancelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFlowCancel(ctx context.Context, body PostFlowCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowCoupons request
	GetFlowCoupons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFlowCreate request with any body
	PostFlowCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFlowCreate(ctx context.Context, body PostFlowCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowMarket request
	GetFlowMarket(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowOrders request
	GetFlowOrders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFlowQuote request with any body
	PostFlowQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFlowQuote(ctx context.Context, body PostFlowQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFlowRatings request with any body
	PostFlowRatingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFlowRatings(ctx context.Context, body PostFlowRatingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFlowRedeem request with any body
	PostFlowRedeemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFlowRedeem(ctx context.Context, body PostFlowRedeemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostFlowStatus request with any body
	PostFlowStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostFlowStatus(ctx context.Context, body PostFlowStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNode request
	GetNode(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNode request with any body
	PostNodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNode(ctx context.Context, body PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeCert request with any body
	PostNodeCertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeCert(ctx context.Context, body PostNodeCertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeConnect request with any body
	PostNodeConnectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeConnect(ctx context.Context, body PostNodeConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeCreate request with any body
	PostNodeCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeCreate(ctx context.Context, body PostNodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeDashboards request with any body
	PostNodeDashboardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeDashboards(ctx context.Context, body PostNodeDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeDelete request with any body
	PostNodeDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeDelete(ctx context.Context, body PostNodeDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeLogs request with any body
	PostNodeLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeLogs(ctx context.Context, body PostNodeLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeMacaroon request with any body
	PostNodeMacaroonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeMacaroon(ctx context.Context, body PostNodeMacaroonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeName request with any body
	PostNodeNameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeName(ctx context.Context, body PostNodeNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeSeed request with any body
	PostNodeSeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeSeed(ctx context.Context, body PostNodeSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeSettings request with any body
	PostNodeSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeSettings(ctx context.Context, body PostNodeSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeStart request with any body
	PostNodeStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeStart(ctx context.Context, body PostNodeStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeStop request with any body
	PostNodeStopWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeStop(ctx context.Context, body PostNodeStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeUpdate request with any body
	PostNodeUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeUpdate(ctx context.Context, body PostNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeUploadSeed request with any body
	PostNodeUploadSeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeUploadSeed(ctx context.Context, body PostNodeUploadSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostNodeWhitelist request with any body
	PostNodeWhitelistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostNodeWhitelist(ctx context.Context, body PostNodeWhitelistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBtcpayserver(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBtcpayserverRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserver(ctx context.Context, body PostBtcpayserverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverCreate(ctx context.Context, body PostBtcpayserverCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverDelete(ctx context.Context, body PostBtcpayserverDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverNodeUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverNodeUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverNodeUpdate(ctx context.Context, body PostBtcpayserverNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverNodeUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverSeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverSeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostBtcpayserverSeed(ctx context.Context, body PostBtcpayserverSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostBtcpayserverSeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDashboards(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDashboardsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboards(ctx context.Context, body PostDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsCreate(ctx context.Context, body PostDashboardsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsDelete(ctx context.Context, body PostDashboardsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsStart(ctx context.Context, body PostDashboardsStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsStopWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsStopRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsStop(ctx context.Context, body PostDashboardsStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsStopRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsUpdateeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsUpdateeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostDashboardsUpdatee(ctx context.Context, body PostDashboardsUpdateeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostDashboardsUpdateeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExport(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExportRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExportWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExportRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostExport(ctx context.Context, body PostExportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostExportRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowBalance(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowBalanceRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowCancelWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowCancelRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowCancel(ctx context.Context, body PostFlowCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowCancelRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowCoupons(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowCouponsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowCreate(ctx context.Context, body PostFlowCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowMarket(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowMarketRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowOrders(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowOrdersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowQuoteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowQuoteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowQuote(ctx context.Context, body PostFlowQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowQuoteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowRatingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowRatingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowRatings(ctx context.Context, body PostFlowRatingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowRatingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowRedeemWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowRedeemRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowRedeem(ctx context.Context, body PostFlowRedeemJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowRedeemRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowStatusWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowStatusRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostFlowStatus(ctx context.Context, body PostFlowStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostFlowStatusRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNode(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNode(ctx context.Context, body PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeCertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeCertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeCert(ctx context.Context, body PostNodeCertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeCertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeConnectWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeConnectRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeConnect(ctx context.Context, body PostNodeConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeConnectRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeCreate(ctx context.Context, body PostNodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeDashboardsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeDashboardsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeDashboards(ctx context.Context, body PostNodeDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeDashboardsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeDeleteWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeDeleteRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeDelete(ctx context.Context, body PostNodeDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeDeleteRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeLogsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeLogsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeLogs(ctx context.Context, body PostNodeLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeLogsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeMacaroonWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeMacaroonRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeMacaroon(ctx context.Context, body PostNodeMacaroonJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeMacaroonRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeNameWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeNameRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeName(ctx context.Context, body PostNodeNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeNameRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeSeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeSeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeSeed(ctx context.Context, body PostNodeSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeSeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeSettings(ctx context.Context, body PostNodeSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeStartWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeStartRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeStart(ctx context.Context, body PostNodeStartJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeStartRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeStopWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeStopRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeStop(ctx context.Context, body PostNodeStopJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeStopRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeUpdateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeUpdateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeUpdate(ctx context.Context, body PostNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeUpdateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeUploadSeedWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeUploadSeedRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeUploadSeed(ctx context.Context, body PostNodeUploadSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeUploadSeedRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeWhitelistWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeWhitelistRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostNodeWhitelist(ctx context.Context, body PostNodeWhitelistJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostNodeWhitelistRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBtcpayserverRequest generates requests for GetBtcpayserver
func NewGetBtcpayserverRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/btcpayserver")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostBtcpayserverRequest calls the generic PostBtcpayserver builder with application/json body
func NewPostBtcpayserverRequest(server string, body PostBtcpayserverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBtcpayserverRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBtcpayserverRequestWithBody generates requests for PostBtcpayserver with any type of body
func NewPostBtcpayserverRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/btcpayserver")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBtcpayserverCreateRequest calls the generic PostBtcpayserverCreate builder with application/json body
func NewPostBtcpayserverCreateRequest(server string, body PostBtcpayserverCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBtcpayserverCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBtcpayserverCreateRequestWithBody generates requests for PostBtcpayserverCreate with any type of body
func NewPostBtcpayserverCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/btcpayserver/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBtcpayserverDeleteRequest calls the generic PostBtcpayserverDelete builder with application/json body
func NewPostBtcpayserverDeleteRequest(server string, body PostBtcpayserverDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBtcpayserverDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBtcpayserverDeleteRequestWithBody generates requests for PostBtcpayserverDelete with any type of body
func NewPostBtcpayserverDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/btcpayserver/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBtcpayserverNodeUpdateRequest calls the generic PostBtcpayserverNodeUpdate builder with application/json body
func NewPostBtcpayserverNodeUpdateRequest(server string, body PostBtcpayserverNodeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBtcpayserverNodeUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBtcpayserverNodeUpdateRequestWithBody generates requests for PostBtcpayserverNodeUpdate with any type of body
func NewPostBtcpayserverNodeUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/btcpayserver/node_update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostBtcpayserverSeedRequest calls the generic PostBtcpayserverSeed builder with application/json body
func NewPostBtcpayserverSeedRequest(server string, body PostBtcpayserverSeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostBtcpayserverSeedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostBtcpayserverSeedRequestWithBody generates requests for PostBtcpayserverSeed with any type of body
func NewPostBtcpayserverSeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/btcpayserver/seed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetDashboardsRequest generates requests for GetDashboards
func NewGetDashboardsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostDashboardsRequest calls the generic PostDashboards builder with application/json body
func NewPostDashboardsRequest(server string, body PostDashboardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDashboardsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDashboardsRequestWithBody generates requests for PostDashboards with any type of body
func NewPostDashboardsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDashboardsCreateRequest calls the generic PostDashboardsCreate builder with application/json body
func NewPostDashboardsCreateRequest(server string, body PostDashboardsCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDashboardsCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDashboardsCreateRequestWithBody generates requests for PostDashboardsCreate with any type of body
func NewPostDashboardsCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDashboardsDeleteRequest calls the generic PostDashboardsDelete builder with application/json body
func NewPostDashboardsDeleteRequest(server string, body PostDashboardsDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDashboardsDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDashboardsDeleteRequestWithBody generates requests for PostDashboardsDelete with any type of body
func NewPostDashboardsDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDashboardsStartRequest calls the generic PostDashboardsStart builder with application/json body
func NewPostDashboardsStartRequest(server string, body PostDashboardsStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDashboardsStartRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDashboardsStartRequestWithBody generates requests for PostDashboardsStart with any type of body
func NewPostDashboardsStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDashboardsStopRequest calls the generic PostDashboardsStop builder with application/json body
func NewPostDashboardsStopRequest(server string, body PostDashboardsStopJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDashboardsStopRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDashboardsStopRequestWithBody generates requests for PostDashboardsStop with any type of body
func NewPostDashboardsStopRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostDashboardsUpdateeRequest calls the generic PostDashboardsUpdatee builder with application/json body
func NewPostDashboardsUpdateeRequest(server string, body PostDashboardsUpdateeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostDashboardsUpdateeRequestWithBody(server, "application/json", bodyReader)
}

// NewPostDashboardsUpdateeRequestWithBody generates requests for PostDashboardsUpdatee with any type of body
func NewPostDashboardsUpdateeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/updatee")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExportRequest generates requests for GetExport
func NewGetExportRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostExportRequest calls the generic PostExport builder with application/json body
func NewPostExportRequest(server string, body PostExportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostExportRequestWithBody(server, "application/json", bodyReader)
}

// NewPostExportRequestWithBody generates requests for PostExport with any type of body
func NewPostExportRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/export")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowBalanceRequest generates requests for GetFlowBalance
func NewGetFlowBalanceRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/balance")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFlowCancelRequest calls the generic PostFlowCancel builder with application/json body
func NewPostFlowCancelRequest(server string, body PostFlowCancelJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFlowCancelRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFlowCancelRequestWithBody generates requests for PostFlowCancel with any type of body
func NewPostFlowCancelRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/cancel")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowCouponsRequest generates requests for GetFlowCoupons
func NewGetFlowCouponsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/coupons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFlowCreateRequest calls the generic PostFlowCreate builder with application/json body
func NewPostFlowCreateRequest(server string, body PostFlowCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFlowCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFlowCreateRequestWithBody generates requests for PostFlowCreate with any type of body
func NewPostFlowCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFlowMarketRequest generates requests for GetFlowMarket
func NewGetFlowMarketRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/market")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowOrdersRequest generates requests for GetFlowOrders
func NewGetFlowOrdersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/orders")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostFlowQuoteRequest calls the generic PostFlowQuote builder with application/json body
func NewPostFlowQuoteRequest(server string, body PostFlowQuoteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFlowQuoteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFlowQuoteRequestWithBody generates requests for PostFlowQuote with any type of body
func NewPostFlowQuoteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/quote")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFlowRatingsRequest calls the generic PostFlowRatings builder with application/json body
func NewPostFlowRatingsRequest(server string, body PostFlowRatingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFlowRatingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFlowRatingsRequestWithBody generates requests for PostFlowRatings with any type of body
func NewPostFlowRatingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/ratings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFlowRedeemRequest calls the generic PostFlowRedeem builder with application/json body
func NewPostFlowRedeemRequest(server string, body PostFlowRedeemJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFlowRedeemRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFlowRedeemRequestWithBody generates requests for PostFlowRedeem with any type of body
func NewPostFlowRedeemRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/redeem")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostFlowStatusRequest calls the generic PostFlowStatus builder with application/json body
func NewPostFlowStatusRequest(server string, body PostFlowStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostFlowStatusRequestWithBody(server, "application/json", bodyReader)
}

// NewPostFlowStatusRequestWithBody generates requests for PostFlowStatus with any type of body
func NewPostFlowStatusRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flow/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetNodeRequest generates requests for GetNode
func NewGetNodeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostNodeRequest calls the generic PostNode builder with application/json body
func NewPostNodeRequest(server string, body PostNodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeRequestWithBody generates requests for PostNode with any type of body
func NewPostNodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeCertRequest calls the generic PostNodeCert builder with application/json body
func NewPostNodeCertRequest(server string, body PostNodeCertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeCertRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeCertRequestWithBody generates requests for PostNodeCert with any type of body
func NewPostNodeCertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/cert")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeConnectRequest calls the generic PostNodeConnect builder with application/json body
func NewPostNodeConnectRequest(server string, body PostNodeConnectJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeConnectRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeConnectRequestWithBody generates requests for PostNodeConnect with any type of body
func NewPostNodeConnectRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/connect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeCreateRequest calls the generic PostNodeCreate builder with application/json body
func NewPostNodeCreateRequest(server string, body PostNodeCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeCreateRequestWithBody generates requests for PostNodeCreate with any type of body
func NewPostNodeCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeDashboardsRequest calls the generic PostNodeDashboards builder with application/json body
func NewPostNodeDashboardsRequest(server string, body PostNodeDashboardsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeDashboardsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeDashboardsRequestWithBody generates requests for PostNodeDashboards with any type of body
func NewPostNodeDashboardsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/dashboards")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeDeleteRequest calls the generic PostNodeDelete builder with application/json body
func NewPostNodeDeleteRequest(server string, body PostNodeDeleteJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeDeleteRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeDeleteRequestWithBody generates requests for PostNodeDelete with any type of body
func NewPostNodeDeleteRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/delete")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeLogsRequest calls the generic PostNodeLogs builder with application/json body
func NewPostNodeLogsRequest(server string, body PostNodeLogsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeLogsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeLogsRequestWithBody generates requests for PostNodeLogs with any type of body
func NewPostNodeLogsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeMacaroonRequest calls the generic PostNodeMacaroon builder with application/json body
func NewPostNodeMacaroonRequest(server string, body PostNodeMacaroonJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeMacaroonRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeMacaroonRequestWithBody generates requests for PostNodeMacaroon with any type of body
func NewPostNodeMacaroonRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/macaroon")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeNameRequest calls the generic PostNodeName builder with application/json body
func NewPostNodeNameRequest(server string, body PostNodeNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeNameRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeNameRequestWithBody generates requests for PostNodeName with any type of body
func NewPostNodeNameRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/name")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeSeedRequest calls the generic PostNodeSeed builder with application/json body
func NewPostNodeSeedRequest(server string, body PostNodeSeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeSeedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeSeedRequestWithBody generates requests for PostNodeSeed with any type of body
func NewPostNodeSeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/seed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeSettingsRequest calls the generic PostNodeSettings builder with application/json body
func NewPostNodeSettingsRequest(server string, body PostNodeSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeSettingsRequestWithBody generates requests for PostNodeSettings with any type of body
func NewPostNodeSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeStartRequest calls the generic PostNodeStart builder with application/json body
func NewPostNodeStartRequest(server string, body PostNodeStartJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeStartRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeStartRequestWithBody generates requests for PostNodeStart with any type of body
func NewPostNodeStartRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/start")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeStopRequest calls the generic PostNodeStop builder with application/json body
func NewPostNodeStopRequest(server string, body PostNodeStopJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeStopRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeStopRequestWithBody generates requests for PostNodeStop with any type of body
func NewPostNodeStopRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/stop")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeUpdateRequest calls the generic PostNodeUpdate builder with application/json body
func NewPostNodeUpdateRequest(server string, body PostNodeUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeUpdateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeUpdateRequestWithBody generates requests for PostNodeUpdate with any type of body
func NewPostNodeUpdateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/update")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeUploadSeedRequest calls the generic PostNodeUploadSeed builder with application/json body
func NewPostNodeUploadSeedRequest(server string, body PostNodeUploadSeedJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeUploadSeedRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeUploadSeedRequestWithBody generates requests for PostNodeUploadSeed with any type of body
func NewPostNodeUploadSeedRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/upload_seed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostNodeWhitelistRequest calls the generic PostNodeWhitelist builder with application/json body
func NewPostNodeWhitelistRequest(server string, body PostNodeWhitelistJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostNodeWhitelistRequestWithBody(server, "application/json", bodyReader)
}

// NewPostNodeWhitelistRequestWithBody generates requests for PostNodeWhitelist with any type of body
func NewPostNodeWhitelistRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/node/whitelist")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBtcpayserver request
	GetBtcpayserverWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBtcpayserverResponse, error)

	// PostBtcpayserver request with any body
	PostBtcpayserverWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverResponse, error)

	PostBtcpayserverWithResponse(ctx context.Context, body PostBtcpayserverJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverResponse, error)

	// PostBtcpayserverCreate request with any body
	PostBtcpayserverCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverCreateResponse, error)

	PostBtcpayserverCreateWithResponse(ctx context.Context, body PostBtcpayserverCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverCreateResponse, error)

	// PostBtcpayserverDelete request with any body
	PostBtcpayserverDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverDeleteResponse, error)

	PostBtcpayserverDeleteWithResponse(ctx context.Context, body PostBtcpayserverDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverDeleteResponse, error)

	// PostBtcpayserverNodeUpdate request with any body
	PostBtcpayserverNodeUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverNodeUpdateResponse, error)

	PostBtcpayserverNodeUpdateWithResponse(ctx context.Context, body PostBtcpayserverNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverNodeUpdateResponse, error)

	// PostBtcpayserverSeed request with any body
	PostBtcpayserverSeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverSeedResponse, error)

	PostBtcpayserverSeedWithResponse(ctx context.Context, body PostBtcpayserverSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverSeedResponse, error)

	// GetDashboards request
	GetDashboardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDashboardsResponse, error)

	// PostDashboards request with any body
	PostDashboardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsResponse, error)

	PostDashboardsWithResponse(ctx context.Context, body PostDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsResponse, error)

	// PostDashboardsCreate request with any body
	PostDashboardsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsCreateResponse, error)

	PostDashboardsCreateWithResponse(ctx context.Context, body PostDashboardsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsCreateResponse, error)

	// PostDashboardsDelete request with any body
	PostDashboardsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsDeleteResponse, error)

	PostDashboardsDeleteWithResponse(ctx context.Context, body PostDashboardsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsDeleteResponse, error)

	// PostDashboardsStart request with any body
	PostDashboardsStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsStartResponse, error)

	PostDashboardsStartWithResponse(ctx context.Context, body PostDashboardsStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsStartResponse, error)

	// PostDashboardsStop request with any body
	PostDashboardsStopWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsStopResponse, error)

	PostDashboardsStopWithResponse(ctx context.Context, body PostDashboardsStopJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsStopResponse, error)

	// PostDashboardsUpdatee request with any body
	PostDashboardsUpdateeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsUpdateeResponse, error)

	PostDashboardsUpdateeWithResponse(ctx context.Context, body PostDashboardsUpdateeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsUpdateeResponse, error)

	// GetExport request
	GetExportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExportResponse, error)

	// PostExport request with any body
	PostExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExportResponse, error)

	PostExportWithResponse(ctx context.Context, body PostExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExportResponse, error)

	// GetFlowBalance request
	GetFlowBalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowBalanceResponse, error)

	// PostFlowCancel request with any body
	PostFlowCancelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowCancelResponse, error)

	PostFlowCancelWithResponse(ctx context.Context, body PostFlowCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowCancelResponse, error)

	// GetFlowCoupons request
	GetFlowCouponsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowCouponsResponse, error)

	// PostFlowCreate request with any body
	PostFlowCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowCreateResponse, error)

	PostFlowCreateWithResponse(ctx context.Context, body PostFlowCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowCreateResponse, error)

	// GetFlowMarket request
	GetFlowMarketWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowMarketResponse, error)

	// GetFlowOrders request
	GetFlowOrdersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowOrdersResponse, error)

	// PostFlowQuote request with any body
	PostFlowQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowQuoteResponse, error)

	PostFlowQuoteWithResponse(ctx context.Context, body PostFlowQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowQuoteResponse, error)

	// PostFlowRatings request with any body
	PostFlowRatingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowRatingsResponse, error)

	PostFlowRatingsWithResponse(ctx context.Context, body PostFlowRatingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowRatingsResponse, error)

	// PostFlowRedeem request with any body
	PostFlowRedeemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowRedeemResponse, error)

	PostFlowRedeemWithResponse(ctx context.Context, body PostFlowRedeemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowRedeemResponse, error)

	// PostFlowStatus request with any body
	PostFlowStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowStatusResponse, error)

	PostFlowStatusWithResponse(ctx context.Context, body PostFlowStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowStatusResponse, error)

	// GetNode request
	GetNodeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodeResponse, error)

	// PostNode request with any body
	PostNodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeResponse, error)

	PostNodeWithResponse(ctx context.Context, body PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeResponse, error)

	// PostNodeCert request with any body
	PostNodeCertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeCertResponse, error)

	PostNodeCertWithResponse(ctx context.Context, body PostNodeCertJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeCertResponse, error)

	// PostNodeConnect request with any body
	PostNodeConnectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeConnectResponse, error)

	PostNodeConnectWithResponse(ctx context.Context, body PostNodeConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeConnectResponse, error)

	// PostNodeCreate request with any body
	PostNodeCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeCreateResponse, error)

	PostNodeCreateWithResponse(ctx context.Context, body PostNodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeCreateResponse, error)

	// PostNodeDashboards request with any body
	PostNodeDashboardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeDashboardsResponse, error)

	PostNodeDashboardsWithResponse(ctx context.Context, body PostNodeDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeDashboardsResponse, error)

	// PostNodeDelete request with any body
	PostNodeDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeDeleteResponse, error)

	PostNodeDeleteWithResponse(ctx context.Context, body PostNodeDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeDeleteResponse, error)

	// PostNodeLogs request with any body
	PostNodeLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeLogsResponse, error)

	PostNodeLogsWithResponse(ctx context.Context, body PostNodeLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeLogsResponse, error)

	// PostNodeMacaroon request with any body
	PostNodeMacaroonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeMacaroonResponse, error)

	PostNodeMacaroonWithResponse(ctx context.Context, body PostNodeMacaroonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeMacaroonResponse, error)

	// PostNodeName request with any body
	PostNodeNameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeNameResponse, error)

	PostNodeNameWithResponse(ctx context.Context, body PostNodeNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeNameResponse, error)

	// PostNodeSeed request with any body
	PostNodeSeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeSeedResponse, error)

	PostNodeSeedWithResponse(ctx context.Context, body PostNodeSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeSeedResponse, error)

	// PostNodeSettings request with any body
	PostNodeSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeSettingsResponse, error)

	PostNodeSettingsWithResponse(ctx context.Context, body PostNodeSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeSettingsResponse, error)

	// PostNodeStart request with any body
	PostNodeStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeStartResponse, error)

	PostNodeStartWithResponse(ctx context.Context, body PostNodeStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeStartResponse, error)

	// PostNodeStop request with any body
	PostNodeStopWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeStopResponse, error)

	PostNodeStopWithResponse(ctx context.Context, body PostNodeStopJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeStopResponse, error)

	// PostNodeUpdate request with any body
	PostNodeUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeUpdateResponse, error)

	PostNodeUpdateWithResponse(ctx context.Context, body PostNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeUpdateResponse, error)

	// PostNodeUploadSeed request with any body
	PostNodeUploadSeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeUploadSeedResponse, error)

	PostNodeUploadSeedWithResponse(ctx context.Context, body PostNodeUploadSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeUploadSeedResponse, error)

	// PostNodeWhitelist request with any body
	PostNodeWhitelistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeWhitelistResponse, error)

	PostNodeWhitelistWithResponse(ctx context.Context, body PostNodeWhitelistJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeWhitelistResponse, error)

	// GetUser request
	GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error)
}

type GetBtcpayserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Btcpayservers List of btcpayservers for the user
		Btcpayservers *[]struct {
			// BtcpayserverId Unique ID for the BTCPay Store
			BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

			// Created Timestamp the dashboard was created
			Created *interface{} `json:"created,omitempty"`
			Expires *string      `json:"expires,omitempty"`

			// Instance Which BTCPay instance it belongs to
			Instance *string `json:"instance,omitempty"`

			// NodeId Unique ID of the node connected to this BTCPay Store
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this BTCPay Store
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the BTCPay Store
			Status *string `json:"status,omitempty"`

			// StoreId BTCPay Store ID created by BTCPay Server
			StoreId *string `json:"store_id,omitempty"`
		} `json:"btcpayservers,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetBtcpayserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBtcpayserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBtcpayserverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BtcpayserverId Unique ID for the BTCPay Store
		BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// Expires Date that the store expires. If a paid store with active subscription this is 'never'.
		Expires *string `json:"expires,omitempty"`

		// Instance Which BTCPay instance it belongs to
		Instance *string `json:"instance,omitempty"`

		// NodeId Unique ID of the node connected to this BTCPay Store
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this BTCPay Store
		NodeName *string `json:"node_name,omitempty"`

		// Password System generated default password for the store
		Password *string `json:"password,omitempty"`

		// PurchaseStatus Payment status for the store
		PurchaseStatus *string `json:"purchase_status,omitempty"`

		// Status Status of the BTCPay Store
		Status *string `json:"status,omitempty"`

		// StoreId BTCPay Store ID created by BTCPay Server
		StoreId *string `json:"store_id,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBtcpayserverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBtcpayserverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBtcpayserverCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BtcpayserverId Unique ID for the BTCPay Store
		BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// Expires Date that the store expires. If a paid store with active subscription this is 'never'.
		Expires *string `json:"expires,omitempty"`

		// Instance Which BTCPay instance it belongs to
		Instance *string `json:"instance,omitempty"`

		// NodeId Unique ID of the node connected to this BTCPay Store
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this BTCPay Store
		NodeName *string `json:"node_name,omitempty"`

		// Password System generated default password for the store
		Password *string `json:"password,omitempty"`

		// PurchaseStatus Payment status for the store
		PurchaseStatus *string `json:"purchase_status,omitempty"`

		// Status Status of the BTCPay Store
		Status *string `json:"status,omitempty"`

		// StoreId BTCPay Store ID created by BTCPay Server
		StoreId *string `json:"store_id,omitempty"`

		// Url URL of the BTCPay Store
		Url *string `json:"url,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBtcpayserverCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBtcpayserverCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBtcpayserverDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BtcpayserverId Unique ID of the BTCPay Store
		BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

		// Status Store's status
		Status *string `json:"status,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBtcpayserverDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBtcpayserverDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBtcpayserverNodeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BtcpayserverId Unique ID for the BTCPay Store
		BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

		// NodeId Unique ID of the node connected to this BTCPay Store
		NodeId *string `json:"node_id,omitempty"`

		// Status Status of the BTCPay Store
		Status *string `json:"status,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBtcpayserverNodeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBtcpayserverNodeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostBtcpayserverSeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BtcpayserverId Unique ID for the BTCPay Store
		BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

		// Seed Encrypted string of the onchain seed
		Seed *string `json:"seed,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostBtcpayserverSeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostBtcpayserverSeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Dashboards List of dashboards for the user
		Dashboards *[]struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		} `json:"dashboards,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// DashboardId Unique ID for the Dashboard
		DashboardId *string `json:"dashboard_id,omitempty"`

		// DashboardName System generated name for the dashboard
		DashboardName *string `json:"dashboard_name,omitempty"`

		// Endpoint Endpoint used to access the dashboard
		Endpoint *string `json:"endpoint,omitempty"`

		// NodeId Unique ID of the node connected to this dashboard
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this dashboard
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the dashboard
		Status *string `json:"status,omitempty"`

		// Type Type of dashboard
		Type *string `json:"type,omitempty"`

		// UpdateAvailable Whether the dashboard has a pending update or not
		UpdateAvailable *bool `json:"update_available,omitempty"`

		// Version Version of the dashboard
		Version *string `json:"version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDashboardsCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// DashboardId Unique ID for the Dashboard
		DashboardId *string `json:"dashboard_id,omitempty"`

		// DashboardName System generated name for the dashboard
		DashboardName *string `json:"dashboard_name,omitempty"`

		// Endpoint Endpoint used to access the dashboard
		Endpoint *string `json:"endpoint,omitempty"`

		// NodeId Unique ID of the node connected to this dashboard
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this dashboard
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the dashboard
		Status *string `json:"status,omitempty"`

		// Type Type of dashboard
		Type *string `json:"type,omitempty"`

		// UpdateAvailable Whether the dashboard has a pending update or not
		UpdateAvailable *bool `json:"update_available,omitempty"`

		// Version Version of the dashboard
		Version *string `json:"version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDashboardsCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDashboardsCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDashboardsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// DashboardId Unique ID for the Dashboard
		DashboardId *string `json:"dashboard_id,omitempty"`

		// DashboardName System generated name for the dashboard
		DashboardName *string `json:"dashboard_name,omitempty"`

		// Endpoint Endpoint used to access the dashboard
		Endpoint *string `json:"endpoint,omitempty"`

		// NodeId Unique ID of the node connected to this dashboard
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this dashboard
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the dashboard
		Status *string `json:"status,omitempty"`

		// Type Type of dashboard
		Type *string `json:"type,omitempty"`

		// UpdateAvailable Whether the dashboard has a pending update or not
		UpdateAvailable *bool `json:"update_available,omitempty"`

		// Version Version of the dashboard
		Version *string `json:"version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDashboardsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDashboardsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDashboardsStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// DashboardId Unique ID for the Dashboard
		DashboardId *string `json:"dashboard_id,omitempty"`

		// DashboardName System generated name for the dashboard
		DashboardName *string `json:"dashboard_name,omitempty"`

		// Endpoint Endpoint used to access the dashboard
		Endpoint *string `json:"endpoint,omitempty"`

		// NodeId Unique ID of the node connected to this dashboard
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this dashboard
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the dashboard
		Status *string `json:"status,omitempty"`

		// Type Type of dashboard
		Type *string `json:"type,omitempty"`

		// UpdateAvailable Whether the dashboard has a pending update or not
		UpdateAvailable *bool `json:"update_available,omitempty"`

		// Version Version of the dashboard
		Version *string `json:"version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDashboardsStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDashboardsStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDashboardsStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// DashboardId Unique ID for the Dashboard
		DashboardId *string `json:"dashboard_id,omitempty"`

		// DashboardName System generated name for the dashboard
		DashboardName *string `json:"dashboard_name,omitempty"`

		// Endpoint Endpoint used to access the dashboard
		Endpoint *string `json:"endpoint,omitempty"`

		// NodeId Unique ID of the node connected to this dashboard
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this dashboard
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the dashboard
		Status *string `json:"status,omitempty"`

		// Type Type of dashboard
		Type *string `json:"type,omitempty"`

		// UpdateAvailable Whether the dashboard has a pending update or not
		UpdateAvailable *bool `json:"update_available,omitempty"`

		// Version Version of the dashboard
		Version *string `json:"version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDashboardsStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDashboardsStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostDashboardsUpdateeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Timestamp the dashboard was created
		Created *string `json:"created,omitempty"`

		// DashboardId Unique ID for the Dashboard
		DashboardId *string `json:"dashboard_id,omitempty"`

		// DashboardName System generated name for the dashboard
		DashboardName *string `json:"dashboard_name,omitempty"`

		// Endpoint Endpoint used to access the dashboard
		Endpoint *string `json:"endpoint,omitempty"`

		// NodeId Unique ID of the node connected to this dashboard
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User given name for the node connected to this dashboard
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the dashboard
		Status *string `json:"status,omitempty"`

		// Type Type of dashboard
		Type *string `json:"type,omitempty"`

		// UpdateAvailable Whether the dashboard has a pending update or not
		UpdateAvailable *bool `json:"update_available,omitempty"`

		// Version Version of the dashboard
		Version *string `json:"version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostDashboardsUpdateeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostDashboardsUpdateeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Exports List of exports for the user
		Exports *[]struct {
			// CreationDate Timestamp the export was created
			CreationDate *string `json:"creation_date,omitempty"`

			// ExpireDate Timestamp the export can no longer be accessed
			ExpireDate *string `json:"expire_date,omitempty"`

			// ExportId Unique ID of the export
			ExportId *string `json:"export_id,omitempty"`

			// Name System generated name for the export
			Name *string `json:"name,omitempty"`

			// NodeId Unique node ID the export was for
			NodeId *string `json:"node_id,omitempty"`

			// Status Status of the export
			Status *string `json:"status,omitempty"`

			// Type Type of export
			Type *string `json:"type,omitempty"`

			// Url URL to download the export from
			Url *string `json:"url,omitempty"`
		} `json:"exports,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostExportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CreationDate Timestamp the export was created
		CreationDate *string `json:"creation_date,omitempty"`

		// ExpireDate Timestamp the export can no longer be accessed
		ExpireDate *string `json:"expire_date,omitempty"`

		// ExportId Unique ID of the export
		ExportId *string `json:"export_id,omitempty"`

		// Name System generated name for the export
		Name *string `json:"name,omitempty"`

		// NodeId Unique node ID the export was for
		NodeId *string `json:"node_id,omitempty"`

		// Status Status of the export
		Status *string `json:"status,omitempty"`

		// Type Type of export
		Type *string `json:"type,omitempty"`

		// Url URL to download the export from
		Url *string `json:"url,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostExportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostExportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowBalanceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Balance Corporate Account balance for monthly invoicing (Only returned for corporate accounts)
		Balance *float32 `json:"balance,omitempty"`

		// Credit Available credit from redeeming coupons, and cancelled orders
		Credit *float32 `json:"credit,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowBalanceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowBalanceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFlowCancelResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AmountDue Amount you would have to pay for the order.
		AmountDue *float32 `json:"amount_due,omitempty"`

		// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
		AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

		// Capacity Amount of requested satoshis of inbound liquidity.
		Capacity *float32 `json:"capacity,omitempty"`

		// CreationDate Date the order was created
		CreationDate *string `json:"creation_date,omitempty"`

		// CreditRefund The amount that has been added to the user's credit.
		CreditRefund *float32 `json:"credit_refund,omitempty"`

		// CreditUsed The part of the total_fee that came from the user's credits.
		CreditUsed *float32 `json:"credit_used,omitempty"`

		// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
		LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

		// LightningInvoice Lightning invoice for the order
		LightningInvoice *string `json:"lightning_invoice,omitempty"`

		// NodeTier Tier of nodes this order can be filled by
		NodeTier *string `json:"node_tier,omitempty"`

		// OnchainAddress Onchain address to pay for the order
		OnchainAddress *string `json:"onchain_address,omitempty"`

		// OrderId Flow Order ID
		OrderId *string `json:"order_id,omitempty"`

		// OrderNonce Pool order identifier
		OrderNonce *string `json:"order_nonce,omitempty"`

		// Paid Whether the order has been paid for or not
		Paid *bool `json:"paid,omitempty"`

		// PoolFee The fee that the Pool service charges you for cancelling.
		PoolFee *float32 `json:"pool_fee,omitempty"`

		// RateBps The BPS used on the order.
		RateBps *float32 `json:"rate_bps,omitempty"`

		// RateFixed Fixed fee rate for the order
		RateFixed *float32 `json:"rate_fixed,omitempty"`

		// SelfChanBalance Amount of requested satoshis of outbound liquidity.
		SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

		// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
		SelfChanBalanceFee *float32 `json:"self_chan_balance_fee,omitempty"`

		// SidecarTicket Generated Sidecar Ticket for the order
		SidecarTicket *string `json:"sidecar_ticket,omitempty"`

		// Status Status of the flow order
		Status *string `json:"status,omitempty"`

		// TotalFee Sum of all the fees.
		TotalFee *float32 `json:"total_fee,omitempty"`

		// VoltageFee The fee that Voltage charges for channel opening.
		VoltageFee *float32 `json:"voltage_fee,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFlowCancelResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFlowCancelResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowCouponsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Coupons List of coupons associated with account
		Coupons *[]struct {
			// Amount Amount of the coupon
			Amount *float32 `json:"amount,omitempty"`

			// Claimed Has coupon been used?
			Claimed *bool `json:"claimed,omitempty"`

			// CouponId ID of the Flow Coupon
			CouponId *string `json:"coupon_id,omitempty"`
		} `json:"coupons,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowCouponsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowCouponsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFlowCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AmountDue Amount you would have to pay for the order.
		AmountDue *float32 `json:"amount_due,omitempty"`

		// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
		AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

		// Capacity Amount of requested satoshis of inbound liquidity.
		Capacity *float32 `json:"capacity,omitempty"`

		// CreationDate Date the order was created
		CreationDate *string `json:"creation_date,omitempty"`

		// CreditUsed The part of the total_fee that came from the user's credits.
		CreditUsed *float32 `json:"credit_used,omitempty"`

		// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
		LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

		// LightningInvoice Lightning invoice for the order
		LightningInvoice *string `json:"lightning_invoice,omitempty"`

		// NodeTier Tier of nodes this order can be filled by
		NodeTier *string `json:"node_tier,omitempty"`

		// OnchainAddress Onchain address to pay for the order
		OnchainAddress *string `json:"onchain_address,omitempty"`

		// OrderId Flow Order ID
		OrderId *string `json:"order_id,omitempty"`

		// OrderNonce Pool order identifier
		OrderNonce *string `json:"order_nonce,omitempty"`

		// Paid Whether the order has been paid for or not
		Paid *bool `json:"paid,omitempty"`

		// PoolFee The fee that the Pool service charges you for cancelling.
		PoolFee *float32 `json:"pool_fee,omitempty"`

		// RateBps Basis Point fee rate for the order
		RateBps *float32 `json:"rate_bps,omitempty"`

		// RateFixed Fixed fee rate for the order
		RateFixed *float32 `json:"rate_fixed,omitempty"`

		// SelfChanBalance Amount of requested satoshis of outbound liquidity.
		SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

		// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
		SelfChanBalanceFee *float32 `json:"self_chan_balance_fee,omitempty"`

		// SidecarTicket Generated Sidecar Ticket for the order
		SidecarTicket *string `json:"sidecar_ticket,omitempty"`

		// Status Status of the flow order
		Status *string `json:"status,omitempty"`

		// TotalFee Sum of all the fees.
		TotalFee *float32 `json:"total_fee,omitempty"`

		// VoltageFee The fee that Voltage charges for channel opening.
		VoltageFee *float32 `json:"voltage_fee,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFlowCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFlowCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowMarketResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		LastBatch *struct {
			// Timestamp timestamp of the previously filled batch
			Timestamp *float32 `json:"timestamp,omitempty"`

			// Txid The bitcoin txid of the last filled batch
			Txid *string `json:"txid,omitempty"`
		} `json:"last_batch,omitempty"`
		MarketInfo *struct {
			// N2016 Information about the 2016 block market
			N2016 *struct {
				// AskOpenInterestUnits Number of ask units (100,000 sats) of open interest per tier
				AskOpenInterestUnits *[]struct {
					// Tier Node Tier
					Tier *string `json:"tier,omitempty"`

					// Value Number of orders for the tier
					Value *float32 `json:"value,omitempty"`
				} `json:"ask_open_interest_units,omitempty"`

				// BidOpenInterestUnits Number of bid units (100,000 sats) of open interest per tier
				BidOpenInterestUnits *[]struct {
					// Tier Node Tier
					Tier *string `json:"tier,omitempty"`

					// Value Number of orders for the tier
					Value *float32 `json:"value,omitempty"`
				} `json:"bid_open_interest_units,omitempty"`

				// NumAsks Number of asks per tier
				NumAsks *[]struct {
					// Tier Node Tier
					Tier *string `json:"tier,omitempty"`

					// Value Number of orders for the tier
					Value *float32 `json:"value,omitempty"`
				} `json:"num_asks,omitempty"`

				// NumBids Number of asks per tier
				NumBids *[]struct {
					// Tier Node Tier
					Tier *string `json:"tier,omitempty"`

					// Value Number of orders for the tier
					Value *float32 `json:"value,omitempty"`
				} `json:"num_bids,omitempty"`
			} `json:"2016,omitempty"`
		} `json:"market_info,omitempty"`
		NextBatch *struct {
			// Timestamp closing timestamp of next potential batch
			Timestamp *float32 `json:"timestamp,omitempty"`
		} `json:"next_batch,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowMarketResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowMarketResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowOrdersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Orders List of orders
		Orders *[]struct {
			// AmountDue Amount you would have to pay for the order.
			AmountDue *float32 `json:"amount_due,omitempty"`

			// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
			AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

			// Capacity Amount of requested satoshis of inbound liquidity.
			Capacity *float32 `json:"capacity,omitempty"`

			// CreationDate Date the order was created
			CreationDate *string `json:"creation_date,omitempty"`

			// CreditRefund The amount that has been added to the user's credit. (Only shown if order was cancelled)
			CreditRefund *float32 `json:"credit_refund,omitempty"`

			// CreditUsed The part of the total_fee that came from the user's credits.
			CreditUsed *float32 `json:"credit_used,omitempty"`

			// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
			LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

			// NodeTier Tier of nodes this order can be filled by
			NodeTier *string `json:"node_tier,omitempty"`

			// OrderId Flow Order ID
			OrderId *string `json:"order_id,omitempty"`

			// OrderNonce Pool order identifier
			OrderNonce *string `json:"order_nonce,omitempty"`

			// Paid Whether the order has been paid for or not
			Paid *bool `json:"paid,omitempty"`

			// RateBps Fixed fee rate for the order
			RateBps *float32 `json:"rate_bps,omitempty"`

			// RateFixed Fixed fee rate for the order
			RateFixed *float32 `json:"rate_fixed,omitempty"`

			// SelfChanBalance Amount of requested satoshis of outbound liquidity.
			SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

			// Status Status of the flow order
			Status *string `json:"status,omitempty"`
		} `json:"orders,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFlowOrdersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowOrdersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFlowQuoteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AmountDue Amount you would have to pay for the order.
		AmountDue *float32 `json:"amount_due,omitempty"`

		// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
		AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

		// Capacity Amount of requested satoshis of inbound liquidity.
		Capacity *float32 `json:"capacity,omitempty"`

		// CorporateAccount Whether the account is a corporate account or not.
		CorporateAccount *bool `json:"corporate_account,omitempty"`

		// CreditUsed Amount of Flow credit that would've been used for this order.
		CreditUsed *float32 `json:"credit_used,omitempty"`

		// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
		LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

		// PoolFee The fee that the Pool service charges you for cancelling.
		PoolFee *float32 `json:"pool_fee,omitempty"`

		// RateBps The BPS used on the order.
		RateBps *float32 `json:"rate_bps,omitempty"`

		// RateFixed The equivalent fixed rate in Parts Per Billion for the order.
		RateFixed *float32 `json:"rate_fixed,omitempty"`

		// SelfChanBalance Amount of requested satoshis of outbound liquidity.
		SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

		// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
		SelfChanBalanceFee *float32 `json:"self_chan_balance_fee,omitempty"`

		// TotalFee Sum of all the fees.
		TotalFee *float32 `json:"total_fee,omitempty"`

		// VoltageFee The fee that Voltage charges for channel opening.
		VoltageFee *float32 `json:"voltage_fee,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFlowQuoteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFlowQuoteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFlowRatingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NodePubkey Public key of the requsted node
		NodePubkey *string `json:"node_pubkey,omitempty"`

		// NodeTier Pool Tier of the ndoe
		NodeTier *string `json:"node_tier,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFlowRatingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFlowRatingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFlowRedeemResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CouponAmount The value of the coupon
		CouponAmount *float32 `json:"coupon_amount,omitempty"`

		// CouponId The coupon id which was redeemed
		CouponId *string `json:"coupon_id,omitempty"`

		// Credit The total credit the user has after redeeming
		Credit *float32 `json:"credit,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFlowRedeemResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFlowRedeemResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostFlowStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AmountDue Amount you would have to pay for the order.
		AmountDue *string `json:"amount_due,omitempty"`

		// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
		AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

		// Capacity Amount of requested satoshis of inbound liquidity.
		Capacity *string `json:"capacity,omitempty"`

		// CreationDate Date the order was created
		CreationDate *string `json:"creation_date,omitempty"`

		// CreditRefund The amount that has been added to the user's credit.
		CreditRefund *string `json:"credit_refund,omitempty"`

		// CreditUsed The part of the total_fee that came from the user's credits.
		CreditUsed *string `json:"credit_used,omitempty"`

		// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
		LeaseDurationBlocks *string `json:"lease_duration_blocks,omitempty"`

		// LightningInvoice Lightning invoice for the order
		LightningInvoice *string `json:"lightning_invoice,omitempty"`

		// NodeTier Tier of nodes this order can be filled by
		NodeTier *string `json:"node_tier,omitempty"`

		// OnchainAddress Onchain address to pay for the order
		OnchainAddress *string `json:"onchain_address,omitempty"`

		// OrderId Flow Order ID
		OrderId *string `json:"order_id,omitempty"`

		// OrderNonce Pool order identifier
		OrderNonce *string `json:"order_nonce,omitempty"`

		// Paid Whether the order has been paid for or not
		Paid *bool `json:"paid,omitempty"`

		// PoolFee The fee that the Pool service charges you for cancelling.
		PoolFee *string `json:"pool_fee,omitempty"`

		// RateBps The BPS used on the order.
		RateBps *string `json:"rate_bps,omitempty"`

		// RateFixed Fixed fee rate for the order
		RateFixed *float32 `json:"rate_fixed,omitempty"`

		// SelfChanBalance Amount of requested satoshis of outbound liquidity.
		SelfChanBalance *string `json:"self_chan_balance,omitempty"`

		// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
		SelfChanBalanceFee *string `json:"self_chan_balance_fee,omitempty"`

		// SidecarTicket Generated Sidecar Ticket for the order
		SidecarTicket *string `json:"sidecar_ticket,omitempty"`

		// Status Status of the flow order
		Status *string `json:"status,omitempty"`

		// TotalFee Sum of all the fees.
		TotalFee *string `json:"total_fee,omitempty"`

		// VoltageFee The fee that Voltage charges for channel opening.
		VoltageFee *string `json:"voltage_fee,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostFlowStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostFlowStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Nodes List of nodes for the user
		Nodes *[]struct {
			// ApiEndpoint API Endpoint for the node.
			ApiEndpoint *string `json:"api_endpoint,omitempty"`

			// Created Date that the node was created.
			Created *string `json:"created,omitempty"`

			// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// LndVersion Version of LND the node is running
			LndVersion *string `json:"lnd_version,omitempty"`

			// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
			Network *string `json:"network,omitempty"`

			// NodeId Unique ID for the node.
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`

			// PurchaseStatus Purchase status of the node.
			PurchaseStatus *string `json:"purchase_status,omitempty"`

			// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
			PurchasedType *string `json:"purchased_type,omitempty"`

			// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
			Status *string `json:"status,omitempty"`

			// Type Type of node, either 'standard' or 'lite'
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Indicates if there is an update available
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// VoltVersion Version of Voltage the node is running
			VoltVersion *string `json:"volt_version,omitempty"`
		} `json:"nodes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NodeDocument
	JSON400      *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeCertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// TlsCert Base64 encoded TLS Certificate
		TlsCert *string `json:"tls_cert,omitempty"`
	}
	JSON400 *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeCertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeCertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeConnectResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Endpoint API Endpoint for the node
		Endpoint *string `json:"endpoint,omitempty"`

		// Macaroon Encrypted value of the macaroon. Left blank if the macaroon doesn't exist.
		Macaroon *string `json:"macaroon,omitempty"`

		// TlsCert Base64 encoded TLS Certificate
		TlsCert *string `json:"tls_cert,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Date that the node was created.
		Created *string `json:"created,omitempty"`

		// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
		Network *string `json:"network,omitempty"`

		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// OwnerId The Unique ID of the user creating the node
		OwnerId *string `json:"owner_id,omitempty"`

		// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
		PurchasedType *string `json:"purchased_type,omitempty"`

		// Type Type of node, either 'standard' or 'lite'
		Type *string `json:"type,omitempty"`

		// UserIp The detected IP address of the user creating the node. Useful for whitelisting.
		UserIp *string `json:"user_ip,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeDashboardsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Dashboards List of dashboards for the node
		Dashboards *[]struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		} `json:"dashboards,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeDashboardsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeDashboardsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ApiEndpoint API Endpoint for the node.
		ApiEndpoint *string `json:"api_endpoint,omitempty"`

		// Created Date that the node was created.
		Created *string `json:"created,omitempty"`

		// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
		Expires *string `json:"expires,omitempty"`

		// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
		Network *string `json:"network,omitempty"`

		// NodeId Unique ID for the node.
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User defined node name given at creation
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
		Status *string `json:"status,omitempty"`

		// Type Type of node, either 'standard' or 'lite'
		Type *string `json:"type,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// LastModified Timestamp of the most recent log line
		LastModified *string `json:"last_modified,omitempty"`

		// LogLines List of the last 100 log lines
		LogLines *[]string `json:"log_lines,omitempty"`

		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User defined node name given at creation
		NodeName *string `json:"node_name,omitempty"`
	}
	JSON400 *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeMacaroonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Created Date the macaroon was uploaded
		Created *string `json:"created,omitempty"`

		// Name Name of the macaroon
		Name *string `json:"name,omitempty"`

		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`
	}
	JSON400 *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeMacaroonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeMacaroonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NodeName Name value sent for checking
		NodeName *string `json:"node_name,omitempty"`

		// Taken Indicates if the name is already taken
		Taken *bool `json:"taken,omitempty"`

		// Valid Indicates if the name is a valid name
		Valid *bool `json:"valid,omitempty"`
	}
	JSON400 *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeSeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User defined node name given at creation
		NodeName *string `json:"node_name,omitempty"`

		// Seed Encrypted seed value
		Seed *string `json:"seed,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeSeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeSeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ApiEndpoint API Endpoint for the node.
		ApiEndpoint *string `json:"api_endpoint,omitempty"`

		// Created Date that the node was created.
		Created *string `json:"created,omitempty"`

		// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
		Expires *string `json:"expires,omitempty"`

		// LndVersion Version of LND the node is running
		LndVersion *string `json:"lnd_version,omitempty"`

		// Macaroons List of backed up macaroons
		Macaroons *[]struct {
			// Created Date it was uploaded
			Created *string `json:"created,omitempty"`

			// Name Name of the macaroon
			Name *string `json:"name,omitempty"`
		} `json:"macaroons,omitempty"`

		// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
		Network *string `json:"network,omitempty"`

		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User defined node name given at creation
		NodeName *string `json:"node_name,omitempty"`

		// PurchaseStatus Purchase status of the node.
		PurchaseStatus *string `json:"purchase_status,omitempty"`

		// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
		PurchasedType *string `json:"purchased_type,omitempty"`

		// Settings Settings for the Lightning Node
		Settings *NodeSettings `json:"settings,omitempty"`

		// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
		Status *string `json:"status,omitempty"`

		// VoltVersion Version of Voltage the node is running
		VoltVersion *string `json:"volt_version,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeStartResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ApiEndpoint API Endpoint for the node.
		ApiEndpoint *string `json:"api_endpoint,omitempty"`

		// Created Date that the node was created.
		Created *string `json:"created,omitempty"`

		// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
		Expires *string `json:"expires,omitempty"`

		// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
		Network *string `json:"network,omitempty"`

		// NodeId Unique ID for the node.
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User defined node name given at creation
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
		Status *string `json:"status,omitempty"`

		// Type Type of node, either 'standard' or 'lite'
		Type *string `json:"type,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeStartResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeStartResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeStopResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ApiEndpoint API Endpoint for the node.
		ApiEndpoint *string `json:"api_endpoint,omitempty"`

		// Created Date that the node was created.
		Created *string `json:"created,omitempty"`

		// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
		Expires *string `json:"expires,omitempty"`

		// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
		Network *string `json:"network,omitempty"`

		// NodeId Unique ID for the node.
		NodeId *string `json:"node_id,omitempty"`

		// NodeName User defined node name given at creation
		NodeName *string `json:"node_name,omitempty"`

		// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
		Status *string `json:"status,omitempty"`

		// Type Type of node, either 'standard' or 'lite'
		Type *string `json:"type,omitempty"`
	}
	JSON400 *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeStopResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeStopResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// LndVersion New version of LND
		LndVersion *string `json:"lnd_version,omitempty"`

		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// VoltVersion New version of Voltage
		VoltVersion *string `json:"volt_version,omitempty"`
	}
	JSON400 *N400
}

// Status returns HTTPResponse.Status
func (r PostNodeUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeUploadSeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeUploadSeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeUploadSeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostNodeWhitelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NodeId Unique ID of the node
		NodeId *string `json:"node_id,omitempty"`

		// Whitelist List of IP Addresses that are allowed to talk to your node
		Whitelist *[]interface{} `json:"whitelist,omitempty"`
	}
	JSON400 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PostNodeWhitelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostNodeWhitelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserDocument
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBtcpayserverWithResponse request returning *GetBtcpayserverResponse
func (c *ClientWithResponses) GetBtcpayserverWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetBtcpayserverResponse, error) {
	rsp, err := c.GetBtcpayserver(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBtcpayserverResponse(rsp)
}

// PostBtcpayserverWithBodyWithResponse request with arbitrary body returning *PostBtcpayserverResponse
func (c *ClientWithResponses) PostBtcpayserverWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverResponse, error) {
	rsp, err := c.PostBtcpayserverWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverResponse(rsp)
}

func (c *ClientWithResponses) PostBtcpayserverWithResponse(ctx context.Context, body PostBtcpayserverJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverResponse, error) {
	rsp, err := c.PostBtcpayserver(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverResponse(rsp)
}

// PostBtcpayserverCreateWithBodyWithResponse request with arbitrary body returning *PostBtcpayserverCreateResponse
func (c *ClientWithResponses) PostBtcpayserverCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverCreateResponse, error) {
	rsp, err := c.PostBtcpayserverCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverCreateResponse(rsp)
}

func (c *ClientWithResponses) PostBtcpayserverCreateWithResponse(ctx context.Context, body PostBtcpayserverCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverCreateResponse, error) {
	rsp, err := c.PostBtcpayserverCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverCreateResponse(rsp)
}

// PostBtcpayserverDeleteWithBodyWithResponse request with arbitrary body returning *PostBtcpayserverDeleteResponse
func (c *ClientWithResponses) PostBtcpayserverDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverDeleteResponse, error) {
	rsp, err := c.PostBtcpayserverDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostBtcpayserverDeleteWithResponse(ctx context.Context, body PostBtcpayserverDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverDeleteResponse, error) {
	rsp, err := c.PostBtcpayserverDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverDeleteResponse(rsp)
}

// PostBtcpayserverNodeUpdateWithBodyWithResponse request with arbitrary body returning *PostBtcpayserverNodeUpdateResponse
func (c *ClientWithResponses) PostBtcpayserverNodeUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverNodeUpdateResponse, error) {
	rsp, err := c.PostBtcpayserverNodeUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverNodeUpdateResponse(rsp)
}

func (c *ClientWithResponses) PostBtcpayserverNodeUpdateWithResponse(ctx context.Context, body PostBtcpayserverNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverNodeUpdateResponse, error) {
	rsp, err := c.PostBtcpayserverNodeUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverNodeUpdateResponse(rsp)
}

// PostBtcpayserverSeedWithBodyWithResponse request with arbitrary body returning *PostBtcpayserverSeedResponse
func (c *ClientWithResponses) PostBtcpayserverSeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostBtcpayserverSeedResponse, error) {
	rsp, err := c.PostBtcpayserverSeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverSeedResponse(rsp)
}

func (c *ClientWithResponses) PostBtcpayserverSeedWithResponse(ctx context.Context, body PostBtcpayserverSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostBtcpayserverSeedResponse, error) {
	rsp, err := c.PostBtcpayserverSeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostBtcpayserverSeedResponse(rsp)
}

// GetDashboardsWithResponse request returning *GetDashboardsResponse
func (c *ClientWithResponses) GetDashboardsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetDashboardsResponse, error) {
	rsp, err := c.GetDashboards(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDashboardsResponse(rsp)
}

// PostDashboardsWithBodyWithResponse request with arbitrary body returning *PostDashboardsResponse
func (c *ClientWithResponses) PostDashboardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsResponse, error) {
	rsp, err := c.PostDashboardsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsResponse(rsp)
}

func (c *ClientWithResponses) PostDashboardsWithResponse(ctx context.Context, body PostDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsResponse, error) {
	rsp, err := c.PostDashboards(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsResponse(rsp)
}

// PostDashboardsCreateWithBodyWithResponse request with arbitrary body returning *PostDashboardsCreateResponse
func (c *ClientWithResponses) PostDashboardsCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsCreateResponse, error) {
	rsp, err := c.PostDashboardsCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsCreateResponse(rsp)
}

func (c *ClientWithResponses) PostDashboardsCreateWithResponse(ctx context.Context, body PostDashboardsCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsCreateResponse, error) {
	rsp, err := c.PostDashboardsCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsCreateResponse(rsp)
}

// PostDashboardsDeleteWithBodyWithResponse request with arbitrary body returning *PostDashboardsDeleteResponse
func (c *ClientWithResponses) PostDashboardsDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsDeleteResponse, error) {
	rsp, err := c.PostDashboardsDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostDashboardsDeleteWithResponse(ctx context.Context, body PostDashboardsDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsDeleteResponse, error) {
	rsp, err := c.PostDashboardsDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsDeleteResponse(rsp)
}

// PostDashboardsStartWithBodyWithResponse request with arbitrary body returning *PostDashboardsStartResponse
func (c *ClientWithResponses) PostDashboardsStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsStartResponse, error) {
	rsp, err := c.PostDashboardsStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsStartResponse(rsp)
}

func (c *ClientWithResponses) PostDashboardsStartWithResponse(ctx context.Context, body PostDashboardsStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsStartResponse, error) {
	rsp, err := c.PostDashboardsStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsStartResponse(rsp)
}

// PostDashboardsStopWithBodyWithResponse request with arbitrary body returning *PostDashboardsStopResponse
func (c *ClientWithResponses) PostDashboardsStopWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsStopResponse, error) {
	rsp, err := c.PostDashboardsStopWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsStopResponse(rsp)
}

func (c *ClientWithResponses) PostDashboardsStopWithResponse(ctx context.Context, body PostDashboardsStopJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsStopResponse, error) {
	rsp, err := c.PostDashboardsStop(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsStopResponse(rsp)
}

// PostDashboardsUpdateeWithBodyWithResponse request with arbitrary body returning *PostDashboardsUpdateeResponse
func (c *ClientWithResponses) PostDashboardsUpdateeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostDashboardsUpdateeResponse, error) {
	rsp, err := c.PostDashboardsUpdateeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsUpdateeResponse(rsp)
}

func (c *ClientWithResponses) PostDashboardsUpdateeWithResponse(ctx context.Context, body PostDashboardsUpdateeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostDashboardsUpdateeResponse, error) {
	rsp, err := c.PostDashboardsUpdatee(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostDashboardsUpdateeResponse(rsp)
}

// GetExportWithResponse request returning *GetExportResponse
func (c *ClientWithResponses) GetExportWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetExportResponse, error) {
	rsp, err := c.GetExport(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExportResponse(rsp)
}

// PostExportWithBodyWithResponse request with arbitrary body returning *PostExportResponse
func (c *ClientWithResponses) PostExportWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostExportResponse, error) {
	rsp, err := c.PostExportWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExportResponse(rsp)
}

func (c *ClientWithResponses) PostExportWithResponse(ctx context.Context, body PostExportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostExportResponse, error) {
	rsp, err := c.PostExport(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostExportResponse(rsp)
}

// GetFlowBalanceWithResponse request returning *GetFlowBalanceResponse
func (c *ClientWithResponses) GetFlowBalanceWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowBalanceResponse, error) {
	rsp, err := c.GetFlowBalance(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowBalanceResponse(rsp)
}

// PostFlowCancelWithBodyWithResponse request with arbitrary body returning *PostFlowCancelResponse
func (c *ClientWithResponses) PostFlowCancelWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowCancelResponse, error) {
	rsp, err := c.PostFlowCancelWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowCancelResponse(rsp)
}

func (c *ClientWithResponses) PostFlowCancelWithResponse(ctx context.Context, body PostFlowCancelJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowCancelResponse, error) {
	rsp, err := c.PostFlowCancel(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowCancelResponse(rsp)
}

// GetFlowCouponsWithResponse request returning *GetFlowCouponsResponse
func (c *ClientWithResponses) GetFlowCouponsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowCouponsResponse, error) {
	rsp, err := c.GetFlowCoupons(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowCouponsResponse(rsp)
}

// PostFlowCreateWithBodyWithResponse request with arbitrary body returning *PostFlowCreateResponse
func (c *ClientWithResponses) PostFlowCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowCreateResponse, error) {
	rsp, err := c.PostFlowCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowCreateResponse(rsp)
}

func (c *ClientWithResponses) PostFlowCreateWithResponse(ctx context.Context, body PostFlowCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowCreateResponse, error) {
	rsp, err := c.PostFlowCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowCreateResponse(rsp)
}

// GetFlowMarketWithResponse request returning *GetFlowMarketResponse
func (c *ClientWithResponses) GetFlowMarketWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowMarketResponse, error) {
	rsp, err := c.GetFlowMarket(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowMarketResponse(rsp)
}

// GetFlowOrdersWithResponse request returning *GetFlowOrdersResponse
func (c *ClientWithResponses) GetFlowOrdersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetFlowOrdersResponse, error) {
	rsp, err := c.GetFlowOrders(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowOrdersResponse(rsp)
}

// PostFlowQuoteWithBodyWithResponse request with arbitrary body returning *PostFlowQuoteResponse
func (c *ClientWithResponses) PostFlowQuoteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowQuoteResponse, error) {
	rsp, err := c.PostFlowQuoteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowQuoteResponse(rsp)
}

func (c *ClientWithResponses) PostFlowQuoteWithResponse(ctx context.Context, body PostFlowQuoteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowQuoteResponse, error) {
	rsp, err := c.PostFlowQuote(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowQuoteResponse(rsp)
}

// PostFlowRatingsWithBodyWithResponse request with arbitrary body returning *PostFlowRatingsResponse
func (c *ClientWithResponses) PostFlowRatingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowRatingsResponse, error) {
	rsp, err := c.PostFlowRatingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowRatingsResponse(rsp)
}

func (c *ClientWithResponses) PostFlowRatingsWithResponse(ctx context.Context, body PostFlowRatingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowRatingsResponse, error) {
	rsp, err := c.PostFlowRatings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowRatingsResponse(rsp)
}

// PostFlowRedeemWithBodyWithResponse request with arbitrary body returning *PostFlowRedeemResponse
func (c *ClientWithResponses) PostFlowRedeemWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowRedeemResponse, error) {
	rsp, err := c.PostFlowRedeemWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowRedeemResponse(rsp)
}

func (c *ClientWithResponses) PostFlowRedeemWithResponse(ctx context.Context, body PostFlowRedeemJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowRedeemResponse, error) {
	rsp, err := c.PostFlowRedeem(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowRedeemResponse(rsp)
}

// PostFlowStatusWithBodyWithResponse request with arbitrary body returning *PostFlowStatusResponse
func (c *ClientWithResponses) PostFlowStatusWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostFlowStatusResponse, error) {
	rsp, err := c.PostFlowStatusWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowStatusResponse(rsp)
}

func (c *ClientWithResponses) PostFlowStatusWithResponse(ctx context.Context, body PostFlowStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostFlowStatusResponse, error) {
	rsp, err := c.PostFlowStatus(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostFlowStatusResponse(rsp)
}

// GetNodeWithResponse request returning *GetNodeResponse
func (c *ClientWithResponses) GetNodeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNodeResponse, error) {
	rsp, err := c.GetNode(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodeResponse(rsp)
}

// PostNodeWithBodyWithResponse request with arbitrary body returning *PostNodeResponse
func (c *ClientWithResponses) PostNodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeResponse, error) {
	rsp, err := c.PostNodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeResponse(rsp)
}

func (c *ClientWithResponses) PostNodeWithResponse(ctx context.Context, body PostNodeJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeResponse, error) {
	rsp, err := c.PostNode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeResponse(rsp)
}

// PostNodeCertWithBodyWithResponse request with arbitrary body returning *PostNodeCertResponse
func (c *ClientWithResponses) PostNodeCertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeCertResponse, error) {
	rsp, err := c.PostNodeCertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeCertResponse(rsp)
}

func (c *ClientWithResponses) PostNodeCertWithResponse(ctx context.Context, body PostNodeCertJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeCertResponse, error) {
	rsp, err := c.PostNodeCert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeCertResponse(rsp)
}

// PostNodeConnectWithBodyWithResponse request with arbitrary body returning *PostNodeConnectResponse
func (c *ClientWithResponses) PostNodeConnectWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeConnectResponse, error) {
	rsp, err := c.PostNodeConnectWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeConnectResponse(rsp)
}

func (c *ClientWithResponses) PostNodeConnectWithResponse(ctx context.Context, body PostNodeConnectJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeConnectResponse, error) {
	rsp, err := c.PostNodeConnect(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeConnectResponse(rsp)
}

// PostNodeCreateWithBodyWithResponse request with arbitrary body returning *PostNodeCreateResponse
func (c *ClientWithResponses) PostNodeCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeCreateResponse, error) {
	rsp, err := c.PostNodeCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeCreateResponse(rsp)
}

func (c *ClientWithResponses) PostNodeCreateWithResponse(ctx context.Context, body PostNodeCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeCreateResponse, error) {
	rsp, err := c.PostNodeCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeCreateResponse(rsp)
}

// PostNodeDashboardsWithBodyWithResponse request with arbitrary body returning *PostNodeDashboardsResponse
func (c *ClientWithResponses) PostNodeDashboardsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeDashboardsResponse, error) {
	rsp, err := c.PostNodeDashboardsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeDashboardsResponse(rsp)
}

func (c *ClientWithResponses) PostNodeDashboardsWithResponse(ctx context.Context, body PostNodeDashboardsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeDashboardsResponse, error) {
	rsp, err := c.PostNodeDashboards(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeDashboardsResponse(rsp)
}

// PostNodeDeleteWithBodyWithResponse request with arbitrary body returning *PostNodeDeleteResponse
func (c *ClientWithResponses) PostNodeDeleteWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeDeleteResponse, error) {
	rsp, err := c.PostNodeDeleteWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeDeleteResponse(rsp)
}

func (c *ClientWithResponses) PostNodeDeleteWithResponse(ctx context.Context, body PostNodeDeleteJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeDeleteResponse, error) {
	rsp, err := c.PostNodeDelete(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeDeleteResponse(rsp)
}

// PostNodeLogsWithBodyWithResponse request with arbitrary body returning *PostNodeLogsResponse
func (c *ClientWithResponses) PostNodeLogsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeLogsResponse, error) {
	rsp, err := c.PostNodeLogsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeLogsResponse(rsp)
}

func (c *ClientWithResponses) PostNodeLogsWithResponse(ctx context.Context, body PostNodeLogsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeLogsResponse, error) {
	rsp, err := c.PostNodeLogs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeLogsResponse(rsp)
}

// PostNodeMacaroonWithBodyWithResponse request with arbitrary body returning *PostNodeMacaroonResponse
func (c *ClientWithResponses) PostNodeMacaroonWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeMacaroonResponse, error) {
	rsp, err := c.PostNodeMacaroonWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeMacaroonResponse(rsp)
}

func (c *ClientWithResponses) PostNodeMacaroonWithResponse(ctx context.Context, body PostNodeMacaroonJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeMacaroonResponse, error) {
	rsp, err := c.PostNodeMacaroon(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeMacaroonResponse(rsp)
}

// PostNodeNameWithBodyWithResponse request with arbitrary body returning *PostNodeNameResponse
func (c *ClientWithResponses) PostNodeNameWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeNameResponse, error) {
	rsp, err := c.PostNodeNameWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeNameResponse(rsp)
}

func (c *ClientWithResponses) PostNodeNameWithResponse(ctx context.Context, body PostNodeNameJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeNameResponse, error) {
	rsp, err := c.PostNodeName(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeNameResponse(rsp)
}

// PostNodeSeedWithBodyWithResponse request with arbitrary body returning *PostNodeSeedResponse
func (c *ClientWithResponses) PostNodeSeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeSeedResponse, error) {
	rsp, err := c.PostNodeSeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeSeedResponse(rsp)
}

func (c *ClientWithResponses) PostNodeSeedWithResponse(ctx context.Context, body PostNodeSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeSeedResponse, error) {
	rsp, err := c.PostNodeSeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeSeedResponse(rsp)
}

// PostNodeSettingsWithBodyWithResponse request with arbitrary body returning *PostNodeSettingsResponse
func (c *ClientWithResponses) PostNodeSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeSettingsResponse, error) {
	rsp, err := c.PostNodeSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeSettingsResponse(rsp)
}

func (c *ClientWithResponses) PostNodeSettingsWithResponse(ctx context.Context, body PostNodeSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeSettingsResponse, error) {
	rsp, err := c.PostNodeSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeSettingsResponse(rsp)
}

// PostNodeStartWithBodyWithResponse request with arbitrary body returning *PostNodeStartResponse
func (c *ClientWithResponses) PostNodeStartWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeStartResponse, error) {
	rsp, err := c.PostNodeStartWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeStartResponse(rsp)
}

func (c *ClientWithResponses) PostNodeStartWithResponse(ctx context.Context, body PostNodeStartJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeStartResponse, error) {
	rsp, err := c.PostNodeStart(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeStartResponse(rsp)
}

// PostNodeStopWithBodyWithResponse request with arbitrary body returning *PostNodeStopResponse
func (c *ClientWithResponses) PostNodeStopWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeStopResponse, error) {
	rsp, err := c.PostNodeStopWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeStopResponse(rsp)
}

func (c *ClientWithResponses) PostNodeStopWithResponse(ctx context.Context, body PostNodeStopJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeStopResponse, error) {
	rsp, err := c.PostNodeStop(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeStopResponse(rsp)
}

// PostNodeUpdateWithBodyWithResponse request with arbitrary body returning *PostNodeUpdateResponse
func (c *ClientWithResponses) PostNodeUpdateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeUpdateResponse, error) {
	rsp, err := c.PostNodeUpdateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeUpdateResponse(rsp)
}

func (c *ClientWithResponses) PostNodeUpdateWithResponse(ctx context.Context, body PostNodeUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeUpdateResponse, error) {
	rsp, err := c.PostNodeUpdate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeUpdateResponse(rsp)
}

// PostNodeUploadSeedWithBodyWithResponse request with arbitrary body returning *PostNodeUploadSeedResponse
func (c *ClientWithResponses) PostNodeUploadSeedWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeUploadSeedResponse, error) {
	rsp, err := c.PostNodeUploadSeedWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeUploadSeedResponse(rsp)
}

func (c *ClientWithResponses) PostNodeUploadSeedWithResponse(ctx context.Context, body PostNodeUploadSeedJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeUploadSeedResponse, error) {
	rsp, err := c.PostNodeUploadSeed(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeUploadSeedResponse(rsp)
}

// PostNodeWhitelistWithBodyWithResponse request with arbitrary body returning *PostNodeWhitelistResponse
func (c *ClientWithResponses) PostNodeWhitelistWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostNodeWhitelistResponse, error) {
	rsp, err := c.PostNodeWhitelistWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeWhitelistResponse(rsp)
}

func (c *ClientWithResponses) PostNodeWhitelistWithResponse(ctx context.Context, body PostNodeWhitelistJSONRequestBody, reqEditors ...RequestEditorFn) (*PostNodeWhitelistResponse, error) {
	rsp, err := c.PostNodeWhitelist(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostNodeWhitelistResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ParseGetBtcpayserverResponse parses an HTTP response from a GetBtcpayserverWithResponse call
func ParseGetBtcpayserverResponse(rsp *http.Response) (*GetBtcpayserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBtcpayserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Btcpayservers List of btcpayservers for the user
			Btcpayservers *[]struct {
				// BtcpayserverId Unique ID for the BTCPay Store
				BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

				// Created Timestamp the dashboard was created
				Created *interface{} `json:"created,omitempty"`
				Expires *string      `json:"expires,omitempty"`

				// Instance Which BTCPay instance it belongs to
				Instance *string `json:"instance,omitempty"`

				// NodeId Unique ID of the node connected to this BTCPay Store
				NodeId *string `json:"node_id,omitempty"`

				// NodeName User given name for the node connected to this BTCPay Store
				NodeName *string `json:"node_name,omitempty"`

				// Status Status of the BTCPay Store
				Status *string `json:"status,omitempty"`

				// StoreId BTCPay Store ID created by BTCPay Server
				StoreId *string `json:"store_id,omitempty"`
			} `json:"btcpayservers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBtcpayserverResponse parses an HTTP response from a PostBtcpayserverWithResponse call
func ParsePostBtcpayserverResponse(rsp *http.Response) (*PostBtcpayserverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBtcpayserverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BtcpayserverId Unique ID for the BTCPay Store
			BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// Expires Date that the store expires. If a paid store with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// Instance Which BTCPay instance it belongs to
			Instance *string `json:"instance,omitempty"`

			// NodeId Unique ID of the node connected to this BTCPay Store
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this BTCPay Store
			NodeName *string `json:"node_name,omitempty"`

			// Password System generated default password for the store
			Password *string `json:"password,omitempty"`

			// PurchaseStatus Payment status for the store
			PurchaseStatus *string `json:"purchase_status,omitempty"`

			// Status Status of the BTCPay Store
			Status *string `json:"status,omitempty"`

			// StoreId BTCPay Store ID created by BTCPay Server
			StoreId *string `json:"store_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBtcpayserverCreateResponse parses an HTTP response from a PostBtcpayserverCreateWithResponse call
func ParsePostBtcpayserverCreateResponse(rsp *http.Response) (*PostBtcpayserverCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBtcpayserverCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BtcpayserverId Unique ID for the BTCPay Store
			BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// Expires Date that the store expires. If a paid store with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// Instance Which BTCPay instance it belongs to
			Instance *string `json:"instance,omitempty"`

			// NodeId Unique ID of the node connected to this BTCPay Store
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this BTCPay Store
			NodeName *string `json:"node_name,omitempty"`

			// Password System generated default password for the store
			Password *string `json:"password,omitempty"`

			// PurchaseStatus Payment status for the store
			PurchaseStatus *string `json:"purchase_status,omitempty"`

			// Status Status of the BTCPay Store
			Status *string `json:"status,omitempty"`

			// StoreId BTCPay Store ID created by BTCPay Server
			StoreId *string `json:"store_id,omitempty"`

			// Url URL of the BTCPay Store
			Url *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBtcpayserverDeleteResponse parses an HTTP response from a PostBtcpayserverDeleteWithResponse call
func ParsePostBtcpayserverDeleteResponse(rsp *http.Response) (*PostBtcpayserverDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBtcpayserverDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BtcpayserverId Unique ID of the BTCPay Store
			BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

			// Status Store's status
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBtcpayserverNodeUpdateResponse parses an HTTP response from a PostBtcpayserverNodeUpdateWithResponse call
func ParsePostBtcpayserverNodeUpdateResponse(rsp *http.Response) (*PostBtcpayserverNodeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBtcpayserverNodeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BtcpayserverId Unique ID for the BTCPay Store
			BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

			// NodeId Unique ID of the node connected to this BTCPay Store
			NodeId *string `json:"node_id,omitempty"`

			// Status Status of the BTCPay Store
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostBtcpayserverSeedResponse parses an HTTP response from a PostBtcpayserverSeedWithResponse call
func ParsePostBtcpayserverSeedResponse(rsp *http.Response) (*PostBtcpayserverSeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostBtcpayserverSeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BtcpayserverId Unique ID for the BTCPay Store
			BtcpayserverId *string `json:"btcpayserver_id,omitempty"`

			// Seed Encrypted string of the onchain seed
			Seed *string `json:"seed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetDashboardsResponse parses an HTTP response from a GetDashboardsWithResponse call
func ParseGetDashboardsResponse(rsp *http.Response) (*GetDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Dashboards List of dashboards for the user
			Dashboards *[]struct {
				// Created Timestamp the dashboard was created
				Created *string `json:"created,omitempty"`

				// DashboardId Unique ID for the Dashboard
				DashboardId *string `json:"dashboard_id,omitempty"`

				// DashboardName System generated name for the dashboard
				DashboardName *string `json:"dashboard_name,omitempty"`

				// Endpoint Endpoint used to access the dashboard
				Endpoint *string `json:"endpoint,omitempty"`

				// NodeId Unique ID of the node connected to this dashboard
				NodeId *string `json:"node_id,omitempty"`

				// NodeName User given name for the node connected to this dashboard
				NodeName *string `json:"node_name,omitempty"`

				// Status Status of the dashboard
				Status *string `json:"status,omitempty"`

				// Type Type of dashboard
				Type *string `json:"type,omitempty"`

				// UpdateAvailable Whether the dashboard has a pending update or not
				UpdateAvailable *bool `json:"update_available,omitempty"`

				// Version Version of the dashboard
				Version *string `json:"version,omitempty"`
			} `json:"dashboards,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostDashboardsResponse parses an HTTP response from a PostDashboardsWithResponse call
func ParsePostDashboardsResponse(rsp *http.Response) (*PostDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostDashboardsCreateResponse parses an HTTP response from a PostDashboardsCreateWithResponse call
func ParsePostDashboardsCreateResponse(rsp *http.Response) (*PostDashboardsCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDashboardsCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostDashboardsDeleteResponse parses an HTTP response from a PostDashboardsDeleteWithResponse call
func ParsePostDashboardsDeleteResponse(rsp *http.Response) (*PostDashboardsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDashboardsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostDashboardsStartResponse parses an HTTP response from a PostDashboardsStartWithResponse call
func ParsePostDashboardsStartResponse(rsp *http.Response) (*PostDashboardsStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDashboardsStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostDashboardsStopResponse parses an HTTP response from a PostDashboardsStopWithResponse call
func ParsePostDashboardsStopResponse(rsp *http.Response) (*PostDashboardsStopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDashboardsStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostDashboardsUpdateeResponse parses an HTTP response from a PostDashboardsUpdateeWithResponse call
func ParsePostDashboardsUpdateeResponse(rsp *http.Response) (*PostDashboardsUpdateeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostDashboardsUpdateeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Timestamp the dashboard was created
			Created *string `json:"created,omitempty"`

			// DashboardId Unique ID for the Dashboard
			DashboardId *string `json:"dashboard_id,omitempty"`

			// DashboardName System generated name for the dashboard
			DashboardName *string `json:"dashboard_name,omitempty"`

			// Endpoint Endpoint used to access the dashboard
			Endpoint *string `json:"endpoint,omitempty"`

			// NodeId Unique ID of the node connected to this dashboard
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User given name for the node connected to this dashboard
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the dashboard
			Status *string `json:"status,omitempty"`

			// Type Type of dashboard
			Type *string `json:"type,omitempty"`

			// UpdateAvailable Whether the dashboard has a pending update or not
			UpdateAvailable *bool `json:"update_available,omitempty"`

			// Version Version of the dashboard
			Version *string `json:"version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetExportResponse parses an HTTP response from a GetExportWithResponse call
func ParseGetExportResponse(rsp *http.Response) (*GetExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Exports List of exports for the user
			Exports *[]struct {
				// CreationDate Timestamp the export was created
				CreationDate *string `json:"creation_date,omitempty"`

				// ExpireDate Timestamp the export can no longer be accessed
				ExpireDate *string `json:"expire_date,omitempty"`

				// ExportId Unique ID of the export
				ExportId *string `json:"export_id,omitempty"`

				// Name System generated name for the export
				Name *string `json:"name,omitempty"`

				// NodeId Unique node ID the export was for
				NodeId *string `json:"node_id,omitempty"`

				// Status Status of the export
				Status *string `json:"status,omitempty"`

				// Type Type of export
				Type *string `json:"type,omitempty"`

				// Url URL to download the export from
				Url *string `json:"url,omitempty"`
			} `json:"exports,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostExportResponse parses an HTTP response from a PostExportWithResponse call
func ParsePostExportResponse(rsp *http.Response) (*PostExportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostExportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CreationDate Timestamp the export was created
			CreationDate *string `json:"creation_date,omitempty"`

			// ExpireDate Timestamp the export can no longer be accessed
			ExpireDate *string `json:"expire_date,omitempty"`

			// ExportId Unique ID of the export
			ExportId *string `json:"export_id,omitempty"`

			// Name System generated name for the export
			Name *string `json:"name,omitempty"`

			// NodeId Unique node ID the export was for
			NodeId *string `json:"node_id,omitempty"`

			// Status Status of the export
			Status *string `json:"status,omitempty"`

			// Type Type of export
			Type *string `json:"type,omitempty"`

			// Url URL to download the export from
			Url *string `json:"url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFlowBalanceResponse parses an HTTP response from a GetFlowBalanceWithResponse call
func ParseGetFlowBalanceResponse(rsp *http.Response) (*GetFlowBalanceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowBalanceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Balance Corporate Account balance for monthly invoicing (Only returned for corporate accounts)
			Balance *float32 `json:"balance,omitempty"`

			// Credit Available credit from redeeming coupons, and cancelled orders
			Credit *float32 `json:"credit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFlowCancelResponse parses an HTTP response from a PostFlowCancelWithResponse call
func ParsePostFlowCancelResponse(rsp *http.Response) (*PostFlowCancelResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFlowCancelResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AmountDue Amount you would have to pay for the order.
			AmountDue *float32 `json:"amount_due,omitempty"`

			// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
			AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

			// Capacity Amount of requested satoshis of inbound liquidity.
			Capacity *float32 `json:"capacity,omitempty"`

			// CreationDate Date the order was created
			CreationDate *string `json:"creation_date,omitempty"`

			// CreditRefund The amount that has been added to the user's credit.
			CreditRefund *float32 `json:"credit_refund,omitempty"`

			// CreditUsed The part of the total_fee that came from the user's credits.
			CreditUsed *float32 `json:"credit_used,omitempty"`

			// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
			LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

			// LightningInvoice Lightning invoice for the order
			LightningInvoice *string `json:"lightning_invoice,omitempty"`

			// NodeTier Tier of nodes this order can be filled by
			NodeTier *string `json:"node_tier,omitempty"`

			// OnchainAddress Onchain address to pay for the order
			OnchainAddress *string `json:"onchain_address,omitempty"`

			// OrderId Flow Order ID
			OrderId *string `json:"order_id,omitempty"`

			// OrderNonce Pool order identifier
			OrderNonce *string `json:"order_nonce,omitempty"`

			// Paid Whether the order has been paid for or not
			Paid *bool `json:"paid,omitempty"`

			// PoolFee The fee that the Pool service charges you for cancelling.
			PoolFee *float32 `json:"pool_fee,omitempty"`

			// RateBps The BPS used on the order.
			RateBps *float32 `json:"rate_bps,omitempty"`

			// RateFixed Fixed fee rate for the order
			RateFixed *float32 `json:"rate_fixed,omitempty"`

			// SelfChanBalance Amount of requested satoshis of outbound liquidity.
			SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

			// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
			SelfChanBalanceFee *float32 `json:"self_chan_balance_fee,omitempty"`

			// SidecarTicket Generated Sidecar Ticket for the order
			SidecarTicket *string `json:"sidecar_ticket,omitempty"`

			// Status Status of the flow order
			Status *string `json:"status,omitempty"`

			// TotalFee Sum of all the fees.
			TotalFee *float32 `json:"total_fee,omitempty"`

			// VoltageFee The fee that Voltage charges for channel opening.
			VoltageFee *float32 `json:"voltage_fee,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFlowCouponsResponse parses an HTTP response from a GetFlowCouponsWithResponse call
func ParseGetFlowCouponsResponse(rsp *http.Response) (*GetFlowCouponsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowCouponsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Coupons List of coupons associated with account
			Coupons *[]struct {
				// Amount Amount of the coupon
				Amount *float32 `json:"amount,omitempty"`

				// Claimed Has coupon been used?
				Claimed *bool `json:"claimed,omitempty"`

				// CouponId ID of the Flow Coupon
				CouponId *string `json:"coupon_id,omitempty"`
			} `json:"coupons,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFlowCreateResponse parses an HTTP response from a PostFlowCreateWithResponse call
func ParsePostFlowCreateResponse(rsp *http.Response) (*PostFlowCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFlowCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AmountDue Amount you would have to pay for the order.
			AmountDue *float32 `json:"amount_due,omitempty"`

			// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
			AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

			// Capacity Amount of requested satoshis of inbound liquidity.
			Capacity *float32 `json:"capacity,omitempty"`

			// CreationDate Date the order was created
			CreationDate *string `json:"creation_date,omitempty"`

			// CreditUsed The part of the total_fee that came from the user's credits.
			CreditUsed *float32 `json:"credit_used,omitempty"`

			// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
			LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

			// LightningInvoice Lightning invoice for the order
			LightningInvoice *string `json:"lightning_invoice,omitempty"`

			// NodeTier Tier of nodes this order can be filled by
			NodeTier *string `json:"node_tier,omitempty"`

			// OnchainAddress Onchain address to pay for the order
			OnchainAddress *string `json:"onchain_address,omitempty"`

			// OrderId Flow Order ID
			OrderId *string `json:"order_id,omitempty"`

			// OrderNonce Pool order identifier
			OrderNonce *string `json:"order_nonce,omitempty"`

			// Paid Whether the order has been paid for or not
			Paid *bool `json:"paid,omitempty"`

			// PoolFee The fee that the Pool service charges you for cancelling.
			PoolFee *float32 `json:"pool_fee,omitempty"`

			// RateBps Basis Point fee rate for the order
			RateBps *float32 `json:"rate_bps,omitempty"`

			// RateFixed Fixed fee rate for the order
			RateFixed *float32 `json:"rate_fixed,omitempty"`

			// SelfChanBalance Amount of requested satoshis of outbound liquidity.
			SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

			// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
			SelfChanBalanceFee *float32 `json:"self_chan_balance_fee,omitempty"`

			// SidecarTicket Generated Sidecar Ticket for the order
			SidecarTicket *string `json:"sidecar_ticket,omitempty"`

			// Status Status of the flow order
			Status *string `json:"status,omitempty"`

			// TotalFee Sum of all the fees.
			TotalFee *float32 `json:"total_fee,omitempty"`

			// VoltageFee The fee that Voltage charges for channel opening.
			VoltageFee *float32 `json:"voltage_fee,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetFlowMarketResponse parses an HTTP response from a GetFlowMarketWithResponse call
func ParseGetFlowMarketResponse(rsp *http.Response) (*GetFlowMarketResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowMarketResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			LastBatch *struct {
				// Timestamp timestamp of the previously filled batch
				Timestamp *float32 `json:"timestamp,omitempty"`

				// Txid The bitcoin txid of the last filled batch
				Txid *string `json:"txid,omitempty"`
			} `json:"last_batch,omitempty"`
			MarketInfo *struct {
				// N2016 Information about the 2016 block market
				N2016 *struct {
					// AskOpenInterestUnits Number of ask units (100,000 sats) of open interest per tier
					AskOpenInterestUnits *[]struct {
						// Tier Node Tier
						Tier *string `json:"tier,omitempty"`

						// Value Number of orders for the tier
						Value *float32 `json:"value,omitempty"`
					} `json:"ask_open_interest_units,omitempty"`

					// BidOpenInterestUnits Number of bid units (100,000 sats) of open interest per tier
					BidOpenInterestUnits *[]struct {
						// Tier Node Tier
						Tier *string `json:"tier,omitempty"`

						// Value Number of orders for the tier
						Value *float32 `json:"value,omitempty"`
					} `json:"bid_open_interest_units,omitempty"`

					// NumAsks Number of asks per tier
					NumAsks *[]struct {
						// Tier Node Tier
						Tier *string `json:"tier,omitempty"`

						// Value Number of orders for the tier
						Value *float32 `json:"value,omitempty"`
					} `json:"num_asks,omitempty"`

					// NumBids Number of asks per tier
					NumBids *[]struct {
						// Tier Node Tier
						Tier *string `json:"tier,omitempty"`

						// Value Number of orders for the tier
						Value *float32 `json:"value,omitempty"`
					} `json:"num_bids,omitempty"`
				} `json:"2016,omitempty"`
			} `json:"market_info,omitempty"`
			NextBatch *struct {
				// Timestamp closing timestamp of next potential batch
				Timestamp *float32 `json:"timestamp,omitempty"`
			} `json:"next_batch,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetFlowOrdersResponse parses an HTTP response from a GetFlowOrdersWithResponse call
func ParseGetFlowOrdersResponse(rsp *http.Response) (*GetFlowOrdersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowOrdersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Orders List of orders
			Orders *[]struct {
				// AmountDue Amount you would have to pay for the order.
				AmountDue *float32 `json:"amount_due,omitempty"`

				// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
				AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

				// Capacity Amount of requested satoshis of inbound liquidity.
				Capacity *float32 `json:"capacity,omitempty"`

				// CreationDate Date the order was created
				CreationDate *string `json:"creation_date,omitempty"`

				// CreditRefund The amount that has been added to the user's credit. (Only shown if order was cancelled)
				CreditRefund *float32 `json:"credit_refund,omitempty"`

				// CreditUsed The part of the total_fee that came from the user's credits.
				CreditUsed *float32 `json:"credit_used,omitempty"`

				// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
				LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

				// NodeTier Tier of nodes this order can be filled by
				NodeTier *string `json:"node_tier,omitempty"`

				// OrderId Flow Order ID
				OrderId *string `json:"order_id,omitempty"`

				// OrderNonce Pool order identifier
				OrderNonce *string `json:"order_nonce,omitempty"`

				// Paid Whether the order has been paid for or not
				Paid *bool `json:"paid,omitempty"`

				// RateBps Fixed fee rate for the order
				RateBps *float32 `json:"rate_bps,omitempty"`

				// RateFixed Fixed fee rate for the order
				RateFixed *float32 `json:"rate_fixed,omitempty"`

				// SelfChanBalance Amount of requested satoshis of outbound liquidity.
				SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

				// Status Status of the flow order
				Status *string `json:"status,omitempty"`
			} `json:"orders,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFlowQuoteResponse parses an HTTP response from a PostFlowQuoteWithResponse call
func ParsePostFlowQuoteResponse(rsp *http.Response) (*PostFlowQuoteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFlowQuoteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AmountDue Amount you would have to pay for the order.
			AmountDue *float32 `json:"amount_due,omitempty"`

			// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
			AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

			// Capacity Amount of requested satoshis of inbound liquidity.
			Capacity *float32 `json:"capacity,omitempty"`

			// CorporateAccount Whether the account is a corporate account or not.
			CorporateAccount *bool `json:"corporate_account,omitempty"`

			// CreditUsed Amount of Flow credit that would've been used for this order.
			CreditUsed *float32 `json:"credit_used,omitempty"`

			// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
			LeaseDurationBlocks *float32 `json:"lease_duration_blocks,omitempty"`

			// PoolFee The fee that the Pool service charges you for cancelling.
			PoolFee *float32 `json:"pool_fee,omitempty"`

			// RateBps The BPS used on the order.
			RateBps *float32 `json:"rate_bps,omitempty"`

			// RateFixed The equivalent fixed rate in Parts Per Billion for the order.
			RateFixed *float32 `json:"rate_fixed,omitempty"`

			// SelfChanBalance Amount of requested satoshis of outbound liquidity.
			SelfChanBalance *float32 `json:"self_chan_balance,omitempty"`

			// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
			SelfChanBalanceFee *float32 `json:"self_chan_balance_fee,omitempty"`

			// TotalFee Sum of all the fees.
			TotalFee *float32 `json:"total_fee,omitempty"`

			// VoltageFee The fee that Voltage charges for channel opening.
			VoltageFee *float32 `json:"voltage_fee,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostFlowRatingsResponse parses an HTTP response from a PostFlowRatingsWithResponse call
func ParsePostFlowRatingsResponse(rsp *http.Response) (*PostFlowRatingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFlowRatingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NodePubkey Public key of the requsted node
			NodePubkey *string `json:"node_pubkey,omitempty"`

			// NodeTier Pool Tier of the ndoe
			NodeTier *string `json:"node_tier,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFlowRedeemResponse parses an HTTP response from a PostFlowRedeemWithResponse call
func ParsePostFlowRedeemResponse(rsp *http.Response) (*PostFlowRedeemResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFlowRedeemResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CouponAmount The value of the coupon
			CouponAmount *float32 `json:"coupon_amount,omitempty"`

			// CouponId The coupon id which was redeemed
			CouponId *string `json:"coupon_id,omitempty"`

			// Credit The total credit the user has after redeeming
			Credit *float32 `json:"credit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostFlowStatusResponse parses an HTTP response from a PostFlowStatusWithResponse call
func ParsePostFlowStatusResponse(rsp *http.Response) (*PostFlowStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostFlowStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AmountDue Amount you would have to pay for the order.
			AmountDue *string `json:"amount_due,omitempty"`

			// AutoBpsRate Whether Voltage calculated the fee rate for your order, or not.
			AutoBpsRate *bool `json:"auto_bps_rate,omitempty"`

			// Capacity Amount of requested satoshis of inbound liquidity.
			Capacity *string `json:"capacity,omitempty"`

			// CreationDate Date the order was created
			CreationDate *string `json:"creation_date,omitempty"`

			// CreditRefund The amount that has been added to the user's credit.
			CreditRefund *string `json:"credit_refund,omitempty"`

			// CreditUsed The part of the total_fee that came from the user's credits.
			CreditUsed *string `json:"credit_used,omitempty"`

			// LeaseDurationBlocks How many blocks you are purchasing the channel. Supported durations are 2016, 4032, 12096, and 52416.
			LeaseDurationBlocks *string `json:"lease_duration_blocks,omitempty"`

			// LightningInvoice Lightning invoice for the order
			LightningInvoice *string `json:"lightning_invoice,omitempty"`

			// NodeTier Tier of nodes this order can be filled by
			NodeTier *string `json:"node_tier,omitempty"`

			// OnchainAddress Onchain address to pay for the order
			OnchainAddress *string `json:"onchain_address,omitempty"`

			// OrderId Flow Order ID
			OrderId *string `json:"order_id,omitempty"`

			// OrderNonce Pool order identifier
			OrderNonce *string `json:"order_nonce,omitempty"`

			// Paid Whether the order has been paid for or not
			Paid *bool `json:"paid,omitempty"`

			// PoolFee The fee that the Pool service charges you for cancelling.
			PoolFee *string `json:"pool_fee,omitempty"`

			// RateBps The BPS used on the order.
			RateBps *string `json:"rate_bps,omitempty"`

			// RateFixed Fixed fee rate for the order
			RateFixed *float32 `json:"rate_fixed,omitempty"`

			// SelfChanBalance Amount of requested satoshis of outbound liquidity.
			SelfChanBalance *string `json:"self_chan_balance,omitempty"`

			// SelfChanBalanceFee The fee that you must pay to get funds on your side of the channel.
			SelfChanBalanceFee *string `json:"self_chan_balance_fee,omitempty"`

			// SidecarTicket Generated Sidecar Ticket for the order
			SidecarTicket *string `json:"sidecar_ticket,omitempty"`

			// Status Status of the flow order
			Status *string `json:"status,omitempty"`

			// TotalFee Sum of all the fees.
			TotalFee *string `json:"total_fee,omitempty"`

			// VoltageFee The fee that Voltage charges for channel opening.
			VoltageFee *string `json:"voltage_fee,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetNodeResponse parses an HTTP response from a GetNodeWithResponse call
func ParseGetNodeResponse(rsp *http.Response) (*GetNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Nodes List of nodes for the user
			Nodes *[]struct {
				// ApiEndpoint API Endpoint for the node.
				ApiEndpoint *string `json:"api_endpoint,omitempty"`

				// Created Date that the node was created.
				Created *string `json:"created,omitempty"`

				// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
				Expires *string `json:"expires,omitempty"`

				// LndVersion Version of LND the node is running
				LndVersion *string `json:"lnd_version,omitempty"`

				// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
				Network *string `json:"network,omitempty"`

				// NodeId Unique ID for the node.
				NodeId *string `json:"node_id,omitempty"`

				// NodeName User defined node name given at creation
				NodeName *string `json:"node_name,omitempty"`

				// PurchaseStatus Purchase status of the node.
				PurchaseStatus *string `json:"purchase_status,omitempty"`

				// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
				PurchasedType *string `json:"purchased_type,omitempty"`

				// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
				Status *string `json:"status,omitempty"`

				// Type Type of node, either 'standard' or 'lite'
				Type *string `json:"type,omitempty"`

				// UpdateAvailable Indicates if there is an update available
				UpdateAvailable *bool `json:"update_available,omitempty"`

				// VoltVersion Version of Voltage the node is running
				VoltVersion *string `json:"volt_version,omitempty"`
			} `json:"nodes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostNodeResponse parses an HTTP response from a PostNodeWithResponse call
func ParsePostNodeResponse(rsp *http.Response) (*PostNodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodeDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeCertResponse parses an HTTP response from a PostNodeCertWithResponse call
func ParsePostNodeCertResponse(rsp *http.Response) (*PostNodeCertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeCertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// TlsCert Base64 encoded TLS Certificate
			TlsCert *string `json:"tls_cert,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeConnectResponse parses an HTTP response from a PostNodeConnectWithResponse call
func ParsePostNodeConnectResponse(rsp *http.Response) (*PostNodeConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Endpoint API Endpoint for the node
			Endpoint *string `json:"endpoint,omitempty"`

			// Macaroon Encrypted value of the macaroon. Left blank if the macaroon doesn't exist.
			Macaroon *string `json:"macaroon,omitempty"`

			// TlsCert Base64 encoded TLS Certificate
			TlsCert *string `json:"tls_cert,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeCreateResponse parses an HTTP response from a PostNodeCreateWithResponse call
func ParsePostNodeCreateResponse(rsp *http.Response) (*PostNodeCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Date that the node was created.
			Created *string `json:"created,omitempty"`

			// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
			Network *string `json:"network,omitempty"`

			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// OwnerId The Unique ID of the user creating the node
			OwnerId *string `json:"owner_id,omitempty"`

			// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
			PurchasedType *string `json:"purchased_type,omitempty"`

			// Type Type of node, either 'standard' or 'lite'
			Type *string `json:"type,omitempty"`

			// UserIp The detected IP address of the user creating the node. Useful for whitelisting.
			UserIp *string `json:"user_ip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeDashboardsResponse parses an HTTP response from a PostNodeDashboardsWithResponse call
func ParsePostNodeDashboardsResponse(rsp *http.Response) (*PostNodeDashboardsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeDashboardsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Dashboards List of dashboards for the node
			Dashboards *[]struct {
				// Created Timestamp the dashboard was created
				Created *string `json:"created,omitempty"`

				// DashboardId Unique ID for the Dashboard
				DashboardId *string `json:"dashboard_id,omitempty"`

				// DashboardName System generated name for the dashboard
				DashboardName *string `json:"dashboard_name,omitempty"`

				// Endpoint Endpoint used to access the dashboard
				Endpoint *string `json:"endpoint,omitempty"`

				// NodeId Unique ID of the node connected to this dashboard
				NodeId *string `json:"node_id,omitempty"`

				// NodeName User given name for the node connected to this dashboard
				NodeName *string `json:"node_name,omitempty"`

				// Status Status of the dashboard
				Status *string `json:"status,omitempty"`

				// Type Type of dashboard
				Type *string `json:"type,omitempty"`

				// UpdateAvailable Whether the dashboard has a pending update or not
				UpdateAvailable *bool `json:"update_available,omitempty"`

				// Version Version of the dashboard
				Version *string `json:"version,omitempty"`
			} `json:"dashboards,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeDeleteResponse parses an HTTP response from a PostNodeDeleteWithResponse call
func ParsePostNodeDeleteResponse(rsp *http.Response) (*PostNodeDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ApiEndpoint API Endpoint for the node.
			ApiEndpoint *string `json:"api_endpoint,omitempty"`

			// Created Date that the node was created.
			Created *string `json:"created,omitempty"`

			// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
			Network *string `json:"network,omitempty"`

			// NodeId Unique ID for the node.
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
			Status *string `json:"status,omitempty"`

			// Type Type of node, either 'standard' or 'lite'
			Type *string `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeLogsResponse parses an HTTP response from a PostNodeLogsWithResponse call
func ParsePostNodeLogsResponse(rsp *http.Response) (*PostNodeLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// LastModified Timestamp of the most recent log line
			LastModified *string `json:"last_modified,omitempty"`

			// LogLines List of the last 100 log lines
			LogLines *[]string `json:"log_lines,omitempty"`

			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeMacaroonResponse parses an HTTP response from a PostNodeMacaroonWithResponse call
func ParsePostNodeMacaroonResponse(rsp *http.Response) (*PostNodeMacaroonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeMacaroonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Created Date the macaroon was uploaded
			Created *string `json:"created,omitempty"`

			// Name Name of the macaroon
			Name *string `json:"name,omitempty"`

			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeNameResponse parses an HTTP response from a PostNodeNameWithResponse call
func ParsePostNodeNameResponse(rsp *http.Response) (*PostNodeNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NodeName Name value sent for checking
			NodeName *string `json:"node_name,omitempty"`

			// Taken Indicates if the name is already taken
			Taken *bool `json:"taken,omitempty"`

			// Valid Indicates if the name is a valid name
			Valid *bool `json:"valid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeSeedResponse parses an HTTP response from a PostNodeSeedWithResponse call
func ParsePostNodeSeedResponse(rsp *http.Response) (*PostNodeSeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeSeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`

			// Seed Encrypted seed value
			Seed *string `json:"seed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeSettingsResponse parses an HTTP response from a PostNodeSettingsWithResponse call
func ParsePostNodeSettingsResponse(rsp *http.Response) (*PostNodeSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ApiEndpoint API Endpoint for the node.
			ApiEndpoint *string `json:"api_endpoint,omitempty"`

			// Created Date that the node was created.
			Created *string `json:"created,omitempty"`

			// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// LndVersion Version of LND the node is running
			LndVersion *string `json:"lnd_version,omitempty"`

			// Macaroons List of backed up macaroons
			Macaroons *[]struct {
				// Created Date it was uploaded
				Created *string `json:"created,omitempty"`

				// Name Name of the macaroon
				Name *string `json:"name,omitempty"`
			} `json:"macaroons,omitempty"`

			// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
			Network *string `json:"network,omitempty"`

			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`

			// PurchaseStatus Purchase status of the node.
			PurchaseStatus *string `json:"purchase_status,omitempty"`

			// PurchasedType Purchase type of the node. Can be either 'trial', 'paid', or 'ondemand'.
			PurchasedType *string `json:"purchased_type,omitempty"`

			// Settings Settings for the Lightning Node
			Settings *NodeSettings `json:"settings,omitempty"`

			// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
			Status *string `json:"status,omitempty"`

			// VoltVersion Version of Voltage the node is running
			VoltVersion *string `json:"volt_version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeStartResponse parses an HTTP response from a PostNodeStartWithResponse call
func ParsePostNodeStartResponse(rsp *http.Response) (*PostNodeStartResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeStartResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ApiEndpoint API Endpoint for the node.
			ApiEndpoint *string `json:"api_endpoint,omitempty"`

			// Created Date that the node was created.
			Created *string `json:"created,omitempty"`

			// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
			Network *string `json:"network,omitempty"`

			// NodeId Unique ID for the node.
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
			Status *string `json:"status,omitempty"`

			// Type Type of node, either 'standard' or 'lite'
			Type *string `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeStopResponse parses an HTTP response from a PostNodeStopWithResponse call
func ParsePostNodeStopResponse(rsp *http.Response) (*PostNodeStopResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeStopResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ApiEndpoint API Endpoint for the node.
			ApiEndpoint *string `json:"api_endpoint,omitempty"`

			// Created Date that the node was created.
			Created *string `json:"created,omitempty"`

			// Expires Date that the node expires. If a paid node with active subscription this is 'never'.
			Expires *string `json:"expires,omitempty"`

			// Network Network the node is running on. Can be either 'testnet' or 'mainnet'.
			Network *string `json:"network,omitempty"`

			// NodeId Unique ID for the node.
			NodeId *string `json:"node_id,omitempty"`

			// NodeName User defined node name given at creation
			NodeName *string `json:"node_name,omitempty"`

			// Status Status of the node. Can be one of 'starting', 'running', 'stopping', 'stopped', 'provisioning', 'waiting_init', 'waiting_unlock'.
			Status *string `json:"status,omitempty"`

			// Type Type of node, either 'standard' or 'lite'
			Type *string `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeUpdateResponse parses an HTTP response from a PostNodeUpdateWithResponse call
func ParsePostNodeUpdateResponse(rsp *http.Response) (*PostNodeUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// LndVersion New version of LND
			LndVersion *string `json:"lnd_version,omitempty"`

			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// VoltVersion New version of Voltage
			VoltVersion *string `json:"volt_version,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest N400
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeUploadSeedResponse parses an HTTP response from a PostNodeUploadSeedWithResponse call
func ParsePostNodeUploadSeedResponse(rsp *http.Response) (*PostNodeUploadSeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeUploadSeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostNodeWhitelistResponse parses an HTTP response from a PostNodeWhitelistWithResponse call
func ParsePostNodeWhitelistResponse(rsp *http.Response) (*PostNodeWhitelistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostNodeWhitelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NodeId Unique ID of the node
			NodeId *string `json:"node_id,omitempty"`

			// Whitelist List of IP Addresses that are allowed to talk to your node
			Whitelist *[]interface{} `json:"whitelist,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
